%\iffalse meta-comment
%
% Copyright (C) 2017-2019 by F. Pantigny
% -----------------------------------
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in:
%
% http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% \fi
% \iffalse
\def\myfileversion{2.2}
\def\myfiledate{2019/12/10}
%
%
%<*batchfile>
\begingroup
\input l3docstrip.tex
\keepsilent
\usedir{tex/latex/witharrows}
\preamble

Copyright (C) 2017-2019 by F. Pantigny
-----------------------------------

This file may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in:

http://www.latex-project.org/lppl.txt

and version 1.3 or later is part of all distributions of LaTeX
version 2005/12/01 or later.

\endpreamble
\askforoverwritefalse
\endgroup
%</batchfile>
%
%<*driver>
\documentclass[dvipsnames]{l3doc}% dvipsnames is for xcolor (loaded by Tikz, loaded by witharrows)
\usepackage{xltxtra}
\usepackage[xetex]{geometry}
\geometry{left=2.8cm,right=2.8cm,top=2.5cm,bottom=2.5cm,papersize={21cm,29.7cm}}
\usepackage[footnotehyper]{witharrows}
\usetikzlibrary{calc}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage[only,llbracket,rrbracket]{stmaryrd}
\usepackage{varwidth}
\labelformat{equation}{(#1)}
\NewDocumentEnvironment {scope} {} {} {}
\def\interitem{\vspace{7mm plus 2 mm minus 3mm}}
\def\emphase{\bgroup\color{RoyalPurple}\let\next=}
\fvset{commandchars=\~\#\@,formatcom={\color{gray}}}
\DeclareMathOperator{\re}{Re}
\skip \footins = 2 \bigskipamount
\parindent 0pt
\DisableCrossrefs
\begin{document}
\DocInput{witharrows.dtx}
\end{document}
%</driver>
% \fi 
% \VerbatimFootnotes
% \title{The package \pkg{witharrows} for plain-TeX and LaTeX\thanks{This document corresponds to the
% version~\myfileversion\space of \pkg{witharrows}, at the date
% of~\myfiledate.}} \author{F. Pantigny \\ \texttt{fpantigny@wanadoo.fr}} 
%
% \maketitle
%
% \hypersetup
%   {
%     pdfinfo = 
%       {
%         Title = The extension 'witharrows' ,
%         Subject = An extension for plain-TeX and LaTeX ,
%         Author = F. Pantigny 
%       }
%   }
%
%
% \begin{abstract}
% The LaTeX package \pkg{witharrows} provides environments |{WithArrows}| and
% |{DispWithArrows}| similar to the environments |{aligned}| and |{align}| of
% \pkg{amsmath} but with the possibility to draw arrows on the right side of the
% alignment. These arrows are usually used to give explanations concerning the
% mathematical calculus presented.
% \end{abstract}
%
%
% \vspace{1cm} 
% In this document, we describe the LaTeX extension
% \pkg{witharrows} (however, \pkg{witharrows} can also be used with plain-TeX:
% see p.~\pageref{plain-TeX}). This package can be used with |xelatex|,
% |lualatex|, |pdflatex| but also by the classical workflow
% |latex|-|dvips|-|ps2pdf| (or Adobe Distiller). This package loads the packages
% \pkg{expl3}, \pkg{l3keys2e}, \pkg{xparse}, \pkg{tikz} and the Tikz libraries
% \pkg{arrows.meta} and \pkg{bending}. The arrows are drawn with Tikz and that's
% why several compilations may be necessary.
%
% \bigskip
% This package provides an environment |{WithArrows}| to construct alignments of
% equations with arrows for the explanations on the right side:
% 
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 ~emphase#\Arrow{we expand}@ \\
%   & = a^2 + 2a + 1  % don't put \\ here
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1  
% \end{WithArrows}$
%
%
%
% \medskip
% The arrow has been drawn with the command |\Arrow| on the row from which it
% starts. The command |\Arrow| must be used in the second column (the best way
% is to put it at the end of the second cell of the row as in the previous
% example).
%
% \medskip
% The environment |{WithArrows}| bears similarities with the environment
% |{aligned}| of \pkg{amsmath} (and |mathtools|). The extension \pkg{witharrows}
% also provides an environment |{DispWithArrows}| which is similar to the
% environment |{align}| of \pkg{amsmath}: cf. p. \pageref{DispWithArrows}.
% 
%
% \section{Options for the shape of the arrows}
%
% The command |\Arrow| has several options. These options can be put between
% square brackets, before, or after the mandatory argument.
%
% The option |jump| gives the number\footnote{It's not possible to give a
% non-positive value to |jump|. See below (p.~\pageref{Backwards}) the way to
% draw an arrow which goes backwards.} of rows the arrow must jump (the default
% value is, of course,~$1$).
%
% 
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 \Arrow[~emphase#jump=2@]{we expand} \\
%   & = (a+b)^2 +  2(a+b) +1 \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 \Arrow[jump=1+1]{we expand} \\
%   & = (a+b)^2 + 2(a+b) +1 \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
%
% \interitem
% It's possible to put several arrows which start from the same row.
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 ~emphase#\Arrow{}\Arrow{}[jump=2]@ \\
%   & = (a+b)^2 + 2(a+b) +1 \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 \Arrow{}\Arrow{}[jump=2] \\
%   & = (a+b)^2 + 2(a+b) +1 \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
%
% \interitem
% The option |xoffset| shifts the arrow to the right (we usually don't want the
% arrows to be stucked on the text). The initial value of |xoffset| is $3$~mm.
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 
% \Arrow[~emphase#xoffset=1cm@]{with \texttt{xoffset=1cm}} \\
%   & = (a+b)^2 + 2(a+b) +1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 
% \Arrow[xoffset=1cm]{with \texttt{xoffset=1cm}} \\
%   & = (a+b)^2 + 2(a+b) +1 
% \end{WithArrows}$
%
%
% \interitem 
% The arrows are drawn with Tikz. That's why the command |\Arrow| has an option
% |tikz| which can be used to give to the arrow (in fact, the command |\path| of
% Tikz) the options proposed by Tikz for such an arrow. The following example
% gives an thick arrow.
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[~emphase#tikz=thick@]{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[tikz=thick]{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \interitem
% It's also possible to change the arrowheads. For example, we can draw an arrow
% which goes backwards with the Tikz option~|<-|.
% \label{Backwards} 
%
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow~emphase#[tikz=<-]@{we factorize} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[tikz=<-]{we factorize} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \interitem
% It's also possible to suppress both tips of the arrow with the Tikz option
% ``|-|''.
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[~emphase#tikz=-@]{very classical} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[tikz=-]{very classical} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \interitem
% In order to have straight arrows instead of curved ones, we must use the Tikz
% option ``|bend left = 0|''.
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow~emphase#[tikz={bend left=0}]@{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[tikz={bend left=0}]{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \smallskip 
% In fact, it's possible to change more drastically the shape or the arrows with
% the option |tikz-code| (presented p.~\pageref{tikz-code}).
%
% \interitem
% It's possible to use the Tikz option ``|text width|'' to control the width of
% the text associated to the arrow.\footnote{It's possible to avoid the
% hyphenations of the words: use the Tikz option ``|align = flush left|'' in
% LaTeX and ``|align = {flushleft,nothyphenated}|'' in ConTeXt.}
% \newcounter{fnnohyphen}
% \setcounter{fnnohyphen}{\thefootnote}
%
% %
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 
% \Arrow[jump=2,~emphase#tikz={text width=5.3cm}@]{We have done...} \\
%   & = (a+b)^2 + 2(a+b) +1 \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 
% \Arrow[jump=2,tikz={text width=5.3cm}]{We have done a two-stages expansion but
% it would have been clever
% to expand with the multinomial theorem.} \\
% & = (a+b)^2 + 2(a+b) +1 \\
% & = a^2 + 2ab + b^2 + 2a + 2b +1
% \end{WithArrows}$
%
%
% \bigskip
% In the environments |{DispWithArrows}| and |{DispWithArrows*}|, there is an
% option |wrap-lines|. With this option, the lines of the labels are
% automatically wrapped on the right: see p.~\pageref{wrap-lines}.
% 
% \interitem
% If we want to change the font of the text associated to the arrow, we can, of
% course, put a command like |\bfseries|, |\large| or |\sffamily| at the
% beginning of the text. But, by default, the texts are composed with a
% combination of |\small| and |\itshape|. When adding |\bfseries| at the
% beginning of the text, we won't suppress the |\small| and the |\itshape| and
% we will consequently have a text in a bold, italic and small font.
% %
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{~emphase#\bfseries@ we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{\bfseries we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \interitem 
% It's possible to put commands |\\| in the text to force new lines\footnote{By
% default, this is not possible in a Tikz node. However, in \pkg{witharrows},
% the nodes are created with the option |align=left|, and, thus, it becomes
% possible.}. However, if we put a |\\| , a command of font placed in the
% beginning of the text will have effect only until the first command |\\| (like
% in an environment |{tabular}|). That's why Tikz gives an option |font| to
% modify the font of the whole text. Nevertheless, if we use the option
% |tikz={font={\bfseries}}|, the default specification of |\small| and
% |\itshape| will be overwritten.
% %
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[~emphase#tikz={font={\bfseries}}@]{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[tikz={font={\bfseries}}]{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \medskip
% If we want exactly the same result as previously, we have to give to the
% option |font| the value |\itshape\small\bfseries|.
%
%
% \interitem 
% The options can be given directly between square brackets to the environment
% |{WithArrows}|. There must be no space between the |\begin{WithArrows}| and
% the opening bracket (|[|) of the options of the environment. Such options
% apply to all the arrows of the environment.\footnote{They also apply to the
% nested environments |{WithArrows}| (with the logical exceptions of
% |interline|, |code-before| and |code-after|).}
% %
% \begin{Verbatim}
% $\begin{WithArrows}[~emphase#tikz=blue@]
% A & = \bigl((a+b)+1\bigr)^2 \Arrow{first expansion.} \\
%   & = (a+b)^2 + 2(a+b) +1 \Arrow{second expansion.} \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}[tikz=blue]
% A & = \bigl((a+b)+1\bigr)^2 \Arrow{first expansion.} \\
%   & = (a+b)^2 + 2(a+b) +1 \Arrow{second expansion.} \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
%
%
% \interitem
% The environment |{WithArrows}| has an option |displaystyle|. With this option,
% all the elements are composed in |\displaystyle| (like in an environment
% |{aligned}| of \pkg{amsmath}).
%
% \medskip
% Without the option |displaystyle|:
% %
% \begin{Verbatim}
% $\begin{WithArrows}
% \int_0^1 (x+1)^2 dx 
% & = \int_0^1 (x^2+2x+1) dx
% \Arrow{linearity of integration}     \\
% & = \int_0^1 x^2 dx + 2 \int_0^1 x dx + \int_0^1 dx \\
% & = \frac13 + 2\frac12 + 1 \\
% & = \frac73
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% \int_0^1 (x+1)^2 dx 
% & = \int_0^1 (x^2+2x+1) dx
% \Arrow{linearity of integration}     \\
% & = \int_0^1 x^2 dx + 2 \int_0^1 x dx + \int_0^1 dx \\
% & = \frac13 + 2\frac12 + 1 \\
% & = \frac73
% \end{WithArrows}$
%
%
% \medskip
% The same example with the option |displaystyle|:\par\nobreak
%
% $\begin{WithArrows}[displaystyle]
% \int_0^1 (x+1)^2 dx 
% & = \int_0^1 (x^2+2x+1) dx
% \Arrow{linearity of integration}     \\
% & = \int_0^1 x^2 dx + 2 \int_0^1 x dx + \int_0^1 dx \\
% & = \frac13 + 2\frac12 + 1 \\
% & = \frac73
% \end{WithArrows}$
%
%
%
% \interitem 
% Almost all the options can also be set at the document level with the command
% |\WithArrowsOptions|. In this case, the scope of the declarations is the
% current TeX group (these declarations are ``semi-global''). For example, if we
% want all the environments |{WithArrows}| composed in |\displaystyle| with blue
% arrows, we can write
% |\WithArrowsOptions{displaystyle,tikz=blue}|.\footnote{It's also possible to
% configure \pkg{witharrows} by modifying the Tikz style |WithArrows/arrow|
% which is the style used by \pkg{witharrows} when drawing an arrow. For
% example, to have the labels in blue with roman (upright) types, one can use
% the following instruction: 
% |\tikzset{WithArrows/arrow/.append style = {blue,font = {}}}|.}
% 
% \begin{Verbatim}
% ~emphase#\WithArrowsOptions{displaystyle,tikz=blue}@
% $\begin{WithArrows}
% \sum_{i=1}^n (x_i+1)^2 
% & = \sum_{i=1}^n (x_i^2+2x_i+1) \Arrow{by linearity}\\
% & = \sum_{i=1}^n x_i^2 + 2\sum_{i=1}^nx_i+ n
% \end{WithArrows}$
% \end{Verbatim}
%
% \begin{scope}
% \WithArrowsOptions{displaystyle,tikz=blue}
% $\begin{WithArrows}
% \sum_{i=1}^n (x_i+1)^2 
% & = \sum_{i=1}^n (x_i^2+2x_i+1) \Arrow{by linearity}\\
% & = \sum_{i=1}^n x_i^2 + 2\sum_{i=1}^nx_i+ n
% \end{WithArrows}$
% \end{scope}
%
%
% \interitem
% The command |\Arrow| is recognized only in the environments |{WithArrows}|. If
% we have a command |\Arrow| previously defined, it's possible to go on using it
% outside the environments |{WithArrows}|.
%
% However, a previouly defined command |\Arrow| may still be useful in an
% environment |{WithArrows}|. If we want to use it in such an environment, it's
% possible to change the name of the command |\Arrow| of the package
% \pkg{witharrows}: there is an option |command-name|\footnote{For historical
% reasons, there is an alias for this option: |CommandName|.} for this purpose.
% The new name of the command must be given to the option \emph{without} the
% leading backslash.
% %
% \begin{Verbatim}
% \NewDocumentCommand {\Arrow} {} {\longmapsto}
% $\begin{WithArrows}[~emphase#command-name=Explanation@]
% f & = \bigl(x \Arrow (x+1)^2\bigr)
% ~emphase#\Explanation{we work directly on fonctions}@\\
% & = \bigl(x \Arrow x^2+2x+1\bigr)
% \end{WithArrows}$
% \end{Verbatim}
% %
% \begin{scope}
% \NewDocumentCommand {\Arrow} {} {\longmapsto}
% $\begin{WithArrows}[command-name=Explanation]
% f & = \bigl(x \Arrow (x+1)^2\bigr)
% \Explanation{we work directly on fonctions}\\
% & = \bigl(x \Arrow x^2+2x+1\bigr)
% \end{WithArrows}$
% \end{scope}
%
%
% \interitem 
% The environment |{WithArrows}| provides also two options |code-before| and
% |code-after|\footnote{For historical reasons, there are aliases for these
% options: |CodeBefore| and |CodeAfter|.} for LaTeX code that will be executed
% at the beginning and at the end of the environment. These options are not
% designed to be hooks (they are available only at the environment level and
% they do not apply to the nested environments).
% %
% \begin{Verbatim}
% $\begin{WithArrows}[~emphase#code-before = \color{blue}@]
% A & = (a+b)^2 \Arrow{we expand} \\
%   & = a^2 + 2ab + b^2 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}[code-before = \color{blue}]
% A & = (a+b)^2 \Arrow{we expand} \\
%   & = a^2 + 2ab + b^2 
% \end{WithArrows}$
% 
% \medskip 
% Special commands are available in |code-after|: a command |\WithArrowsNbLines|
% which gives the number of lines (=rows) of the current environment (this is a
% command and not a counter), a special form of the command |\Arrow| and the
% command |\MultiArrow|: these commands are described in the section concerning
% the nested environments, p.~\pageref{NestedEnv}.
%
% \section{Numbers of columns}
%
% So far, we have used the environment |{WithArrows}| with two columns. However,
% it's possible to use the environment with an arbitrary number of columns with
% the option |format|. The value given to this option is like the preamble of an
% environment |{array}|, that is to say a sequence of letters |r|, |c| and |l|.
% The initial value of the option |format| is, in fact, |rl|.
%
% \bigskip
% For exemple, if we want only one column left-aligned, we use the option |format=l|.
% \begin{Verbatim}
% $\begin{WithArrows}[~emphase#format = l@]
% f(x) \ge g(x) \Arrow{by squaring both sides} \\
% f(x)^2 \ge g(x)^2 \Arrow{by moving to left side} \\
% f(x)^2 - g(x)^2 \ge 0 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}[format = l]
% f(x) \ge g(x) \Arrow{by squaring both sides} \\
% f(x)^2 \ge g(x)^2 \Arrow{by moving to left side} \\
% f(x)^2 - g(x)^2 \ge 0 
% \end{WithArrows}$
%
% \interitem
% In the following example, we use five columns all centered (the environment
% |{DispWithArrows*}| is  presented p.~\pageref{DispWithArrows}).
%
% \begin{Verbatim}
% \begin{DispWithArrows*}[~emphase#format = ccccc@,
%                         wrap-lines,
%                         tikz = {align = flush left},
%                         interline=1mm]
% k & \;\le\; & t & \;\le\; & k+1 \\
% \frac{1}{k+1} & \le & \frac{1}{t} & \le & \frac{1}{k} 
% \Arrow{we can integrate the inequalities since $k \leq k+1$ } \\
% \int\limits_k^{k+1} \frac{d t}{k+1} 
% & \le & \int\limits_k^{k+1} \frac{dt}{t} 
% & \le & \int\limits_k^{k+1} \frac{dt}{k} \\
% \frac{1}{k+1} & \le & \ln(k+1)-\ln(k) & \le & \frac{1}{k} 
% \end{DispWithArrows*}
% \end{Verbatim}
% \begin{DispWithArrows*}[format = ccccc,
%                         wrap-lines,
%                         tikz = {align = flush left},
%                         interline=1mm]
% k & \;\le\; & t & \;\le\; & k+1 \\
% \frac{1}{k+1} & \le & \frac{1}{t} & \le & \frac{1}{k} 
% \Arrow{we can integrate the inequalities since $k \leq k+1$ } \\
% \int\limits_k^{k+1} \frac{d t}{k+1} 
% & \le & \int\limits_k^{k+1} \frac{dt}{t} 
% & \le & \int\limits_k^{k+1} \frac{dt}{k} \\
% \frac{1}{k+1} & \le & \ln(k+1)-\ln(k) & \le & \frac{1}{k} 
% \end{DispWithArrows*}
% 
%
% \section{Precise positioning of the arrows}
%
%
% The environment |{WithArrows}| defines, during the composition of the array,
% two series of nodes materialized in red in the following example.\footnote{The
% option |show-nodes| can be used to materialize the nodes. The nodes are in
% fact Tikz nodes of shape ``rectangle'', but with zero width. An arrow between
% two nodes starts at the \emph{south} anchor of the first node and arrives at
% the \emph{north} anchor of the second node.}
%
% \smallskip
% $\begin{WithArrows}[displaystyle,show-nodes]
% I
% & = \int_{\frac{\pi}4}^0 \ln\Bigl(1+\tan\left(\tfrac{\pi}4-u\right)\Bigr)(-d u) \\
% & = \int_0^{\frac{\pi}4} \ln\Bigl(1+\tan\left(\tfrac{\pi}4-u\right)\Bigr)d u \\
% & = \int_0^{\frac{\pi}4}\ln\left(1+\frac{1-\tan u}{1+\tan u}\right)\, d u \\
% & =\int_0^{\frac{\pi}4}\ln\left(\frac{1+\tan u+1-\tan u}{1+\tan u}\right) d u \\
% & =\int_0^{\frac{\pi}4} \ln\left(\frac2{1+\tan u}\right)\, d u\\
% & =\int_0^{\frac{\pi}4}\bigl(\ln2-\ln(1+\tan u)\bigr)\, d u \\
% & =\frac{\pi}4\ln2-\int_0^{\frac{\pi}4}\ln(1+\tan u)\, d u  \\
% & =\frac{\pi}4\ln2-I 
% \end{WithArrows}$
%
% \bigskip
% The nodes of the left are at the end of each line of text. These nodes will be
% called \emph{left nodes}. The nodes of the right side are aligned vertically
% on the right side of the array. These nodes will be called \emph{right nodes}.
%
% By default, the arrows use the right nodes. We will say that they are in |rr|
% mode ($r$ for \emph{right}). These arrows are vertical (we will say that an
% arrow is \emph{vertical} when its two ends have the same abscissa).
%
%
% \smallskip
% However, it's possible to use the left nodes, or a combination of left and
% right nodes, with one of the options |lr|, |rl| and |ll| ($l$ for
% \emph{left}). Those arrows are, usually, not vertical.
%
%
% Therefore
% $\begin{WithArrows}[displaystyle]
% I
% & = \int_{\frac{\pi}4}^0 \ln\Bigl(1+\tan\left(\tfrac{\pi}4-u\right)\Bigr)(-d u) 
% \Arrow[lr]{This arrow uses the |lr| option.}\\
% & = \int_0^{\frac{\pi}4} \ln\Bigl(1+\tan\left(\tfrac{\pi}4-u\right)\Bigr)d u \\
% & = \int_0^{\frac{\pi}4}\ln\left(1+\frac{1-\tan u}{1+\tan u}\right)\, d u \\
% & =\int_0^{\frac{\pi}4}\ln\left(\frac{1+\tan u+1-\tan u}{1+\tan u}\right) d u 
% \Arrow[ll,jump=2,tikz={text width = 5cm}]{This arrow uses a |ll| option
% and a |jump| equal to $2$}\\ 
% & =\int_0^{\frac{\pi}4} \ln\left(\frac2{1+\tan u}\right)\, d u\\
% & =\int_0^{\frac{\pi}4}\bigl(\ln2-\ln(1+\tan u)\bigr)\, d u \\
% & =\frac{\pi}4\ln2-\int_0^{\frac{\pi}4}\ln(1+\tan u)\, d u  \\
% & =\frac{\pi}4\ln2-I 
% \end{WithArrows}$
%
%
%
% \interitem
% There is also an option called |i| (\emph{i} for \emph{intermediate}). With
% this option, the arrow is vertical and at the leftmost position.
%
% \begin{Verbatim}
% $\begin{WithArrows}
% (a+b)(a+ib)(a-b)(a-ib) 
% & = (a+b)(a-b)\cdot(a+ib)(a-ib) \\
% & = (a^2-b^2)(a^2+b^2) \Arrow~emphase#[i]@{because $(x-y)(x+y)=x^2-y^2$}\\
% & = a^4-b^4 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% (a+b)(a+ib)(a-b)(a-ib) 
% & = (a+b)(a-b)\cdot(a+ib)(a-ib) \\
% & = (a^2-b^2)(a^2+b^2) \Arrow[i]{because $(x-y)(x+y)=x^2-y^2$}\\
% & = a^4-b^4 
% \end{WithArrows}$
%
%
% \interitem 
% The environment |{WithArrows}| gives also a |group| option. With this option,
% \emph{all} the arrows of the environment are grouped on a same vertical line
% and at a leftmost position.
% %
% \begin{Verbatim}[formatcom=\small\color{gray}]
% $\begin{WithArrows}[~emphase#displaystyle,group@]
% 2xy'-3y=\sqrt x
% & \Longleftrightarrow 2x(K'y_0+Ky_0')-3Ky_0 = \sqrt x \\
% & \Longleftrightarrow 2xK'y_0 + K(2xy_0'-3y_0) = \sqrt x \\
% & \Longleftrightarrow 2x K'y_0 = \sqrt x \Arrow{...}\\
% ...
% \end{WithArrows}$
% \end{Verbatim}
%
%
% $\begin{WithArrows}[displaystyle,group]
% 2xy'-3y=\sqrt x
% & \Longleftrightarrow 2x(K'y_0+Ky_0')-3Ky_0 = \sqrt x \\
% & \Longleftrightarrow 2xK'y_0 + K(2xy_0'-3y_0) = \sqrt x \\
% & \Longleftrightarrow 2x K'y_0 = \sqrt x \Arrow{we replace $y_0$ by its value}\\
% & \Longleftrightarrow 2xK'x^{\frac32} = x^{\frac12} \Arrow{simplification of the $x$}\\
% & \Longleftrightarrow K' = \tfrac1{2x^2} \Arrow{antiderivation}\\
% & \Longleftrightarrow K = -\tfrac1{2x} 
% \end{WithArrows}$
%
%
% \bigskip
% The environment |{WithArrows}| gives also a |groups| option (with a \emph{s}
% in the name). With this option, the arrows are divided into several
% ``groups''. Each group is a set of connected\footnote{More precisely: for each
% arrow $a$, we note $i(a)$ the number of its initial row and $f(a)$ the number
% of its final row; for two arrows $a$ and $b$, we say that $a \sim b$ when
% $\llbracket i(a),f(a)\rrbracket \cap \llbracket i(b),f(b)\rrbracket \neq
% \varnothing$; the groups are the equivalence classes of the transitive closure
% of $\sim$.} arrows. All the arrows of a given group are grouped on a same
% vertical line and at a leftmost position.
%
% \bigskip
% $\begin{WithArrows}[groups]
% A & = B \Arrow{one} \\
%   & = C+D \Arrow{two} \\
%   & = D' \\
%   & = E+F+G+H+I \\
%   & = K + L + M \Arrow{three}\\
%   & = N \Arrow{four}\\
%   & = O
% \end{WithArrows}$
%
% \bigskip 
% In an environment which uses the option |group| or the option |groups|, it's
% still possible to give an option of position (|ll|, |lr|, |rl|, |rr| or |i|)
% to an individual arrow\footnote{Such an arrow will be called
% \emph{independent} in the technical documentation}. Such arrow will be drawn
% irrespective of the groups. It's also possible to start a new group by
% applying the option |new-group| to an given arrow.
% 
% \bigskip
% If desired, the option |group| or the option |groups| can be given to the
% command |\WithArrowsOptions| so that it will become the default value. In this
% case, it's still possible to come back to the default behaviour for a given
% environment |{WithArrows}| with the option |rr|: |\begin{WithArrows}[rr]|
%
%
% \vspace{1cm}
% In the following example, we have used the option |groups| for the environment
% and the option |new-group| for the last arrow (that's why the last arrow is not
% aligned with the others).
%
% $\begin{WithArrows}[interline=1mm,groups]
% \sum\limits_{k=0}^n\frac{\cos kx}{\cos^k x}
% & = \sum\limits_{k=0}^n \frac{\Re (e^{ikx})}{(\cos x)^k} 
% \Arrow{$(\cos x)^k$ is real} \\
% & = \sum\limits_{k=0}^n \Re\left(\frac{e^{ikx}}{(\cos x)^k}\right)
% \Arrow{$\Re(z+z')=\Re(z)+\Re(z')$}\\
% & = \Re \left(\sum\limits_{k=0}^n \left(\frac{e^{ix}}{\cos x}\right)^k\right)
% \Arrow{sum of terms of a geometric progression} \\
% & = \Re \left(\frac{1-\left(\frac{e^{ix}}{\cos x}\right)^{n+1}}{1-\frac{e^{ix}}{\cos x}} \right)
% \Arrow{algebraic calculation} \\
% & = \Re \left(\frac{1-\frac{e^{i(n+1)x}}{\cos^{n+1}x}}{1-\frac{e^{ix}}{\cos x}}\right)
% \Arrow{reduction to common denominator} \\
% & = \Re \left(\frac{\frac{\cos^{n+1}x-e^{i(n+1)x}}{\cos^{n+1}x}}{\frac{\cos x-e^{ix}}{\cos x}}\right)
% \Arrow{$\Re(kz) = k\cdot\Re(z)$ if $k$ is real} \\
% & = \frac1{\cos^n x}\Re \left(\frac{\cos^{n+1}x-e^{i(n+1)x}}{\cos x-e^{ix}}\right)
% \Arrow[new-group]{algebraic form of the complexes} \\
% & =\frac1{\cos^n x}\Re\left(\frac{\cos^{n+1}x-(\cos(n+1)x+i\sin(n+1)x)}{\cos x-(\cos x+i\sin x)}\right) \\
% & =\frac1{\cos^n x}\Re\left(\frac{(\cos^{n+1}x-\cos(n+1)x)-i\sin(n+1)x}{-i\sin x}\right) \\
% & = \frac1{\cos^nx}\cdot\frac{\sin(n+1)x}{\sin x}
% \end{WithArrows}$
%
% \interitem
%
% \section[The options 'up' and 'down' for individual arrows]%
%     {The options ``up'' and ``down'' for individual arrows} 
%
% \label{up-and-down}
% At the local level, there are also two options for individuals arrows, called
% ``|up|'' and ``|down|''. The following example illustrates these types of
% arrows:
% 
% \begin{Verbatim}
% \(\begin{WithArrows}
% A & = B 
% \Arrow~emphase#[up]@{an arrow of type \texttt{up}} \\
%   & = C + C + C + C + C + C + C + C  \\
%   & = C + C + C + C + C + C + C + C  
% \Arrow~emphase#[down]@{an arrow of type \texttt{down}} \\
%   & = E + E 
% \end{WithArrows}\)
% \end{Verbatim}
% 
% \vspace{1cm}
% \(\begin{WithArrows}
% A & = B 
% \Arrow[up]{an arrow of type \texttt{up}} \\
%   & = C + C + C + C + C + C + C + C  \\
%   & = C + C + C + C + C + C + C + C  
% \Arrow[down]{an arrow of type \texttt{down}} \\
%   & = E + E 
% \end{WithArrows}\)
%
%
% \vspace{1cm}
% The options |up| and |down| require the package \pkg{varwidth} and the Tikz
% library \pkg{calc}. It they are not loaded, an error will be raised.
%
%
% \interitem
%
% \section{Comparison with the environment \{aligned\}}
%
% |{WithArrows}| bears similarities with the environment |{aligned}| of the
% extension \pkg{amsmath}. These are only similarities because |{WithArrows}|
% has not been written upon the environment |{aligned}|.\footnote{In fact, it's
% possible to use the package \pkg{witharrows} without the package
% \pkg{amsmath}.}
%
% \interitem
% As in the environments of \pkg{amsmath}, it's possible to change the spacing
% between two given rows with the option of the command |\\| of end of line
% (it's also possible to use |\\*| but it has exactly the same effect as |\\|
% since an environment |{WithArrows}| is always unbreakable). This option is
% designed to be used with positive values only.
% %
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{we expand} ~emphase#\\[2ex]@
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{we expand} \\*[2ex]
% \noalign{\vspace{3mm}}
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
%
% \interitem 
% In the environments of \pkg{amsmath} (or \pkg{mathtools}), the spacing between
% rows is fixed by a parameter called |\jot| (it's a dimension and not a skip).
% That's also the case for the environment |{WithArrows}|. An option |jot| has
% been given to the environment |{WithArrows}| in order to change the value of
% this parameter |\jot| for a given environment.\footnote{It's also possible to
% change |\jot| with the environment |{spreadlines}| of \pkg{mathtools}.}
% %
% \begin{Verbatim}
% $\begin{WithArrows}[displaystyle,~emphase#jot=2ex@]
% F & = \frac12G     \Arrow{we expand}\\
%   & = H + \frac12K \Arrow{we go on}\\
%   & = K 
% \end{WithArrows}$
% \end{Verbatim}
%
%
% $\begin{WithArrows}[displaystyle,jot=2ex]
% F & = \frac12G     \Arrow{we expand}\\
%   & = H + \frac12K \Arrow{we go on}\\
%   & = K 
% \end{WithArrows}$
%
%
% \bigskip
% However, this new value of |\jot| will also be used in other alignments
% included in the environment~|{WithArrows}|:
% %
% \begin{Verbatim}
% $\begin{WithArrows}[jot=2ex]
% \varphi(x,y) = 0  & \Leftrightarrow (x+y)^2 + (x+2y)^2 = 0 
% \Arrow{$x$ and $y$ are real}\\
% & \Leftrightarrow \left\{
% \begin{aligned}
% x+y & = 0 \\
% x+2y & = 0 
% \end{aligned}
% \right.
% \end{WithArrows}$
% \end{Verbatim}
%
%
% $\begin{WithArrows}[jot=2ex]
% \varphi(x,y) = 0  & \Leftrightarrow (x+y)^2 + (x+2y)^2 = 0 
% \Arrow{$x$ and $y$ are real}\\
% & \Leftrightarrow \left\{
% \begin{aligned}
% x+y & = 0 \\
% x+2y & = 0 
% \end{aligned}
% \right.
% \end{WithArrows}$
%
% \bigskip
% Maybe this doesn't correspond to the desired outcome. That's why an option
% |interline| is proposed. It's possible to use a skip (=glue) for this option.
% %
% \begin{Verbatim}
% $\begin{WithArrows}[~emphase#interline=2ex@]
% \varphi(x,y) = 0  & \Leftrightarrow (x+y)^2 + (x+2y)^2 = 0 
% \Arrow{$x$ and $y$ are real}\\
% & \Leftrightarrow \left\{
% \begin{aligned}
% x+y & = 0 \\
% x+2y & = 0 \\
% \end{aligned}
% \right.
% \end{WithArrows}$
% \end{Verbatim}
%
%
% $\begin{WithArrows}[interline=2ex]
% \varphi(x,y) = 0  & \Leftrightarrow (x+y)^2 + (x+2y)^2 = 0 
% \Arrow{$x$ and $y$ are real}\\
% & \Leftrightarrow \left\{
% \begin{aligned}
% x+y & = 0 \\
% x+2y & = 0 \\
% \end{aligned}
% \right.
% \end{WithArrows}$
%
%
% \interitem
% Like the environment |{aligned}|, |{WithArrows}| has an option of placement
% which can assume the values |t|, |c| or |b|. However, the initial value is not
% |c| but |t|. If desired, it's possible to have the |c| value as the default
% with the command |\WithArrowsOptions{c}| at the beginning of the document.
% %
% \begin{Verbatim}
% So\enskip
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% So\enskip 
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \bigskip
% The value |c| may be useful, for example, if we want to add curly braces:
%
% \smallskip
% \begin{Verbatim}
% Let's set\enskip $~emphase#\left\{@
% \begin{WithArrows}[~emphase#c@]
% f(x) & = 3x^3+2x^2-x+4 
% \Arrow[tikz=-]{both are polynoms}\\
% g(x) & = 5x^2-5x+6
% \end{WithArrows}
% ~emphase#\right.@$
% \end{Verbatim}
%
%
% Let's set\enskip $\left\{
% \begin{WithArrows}[c]
% f(x) & = 3x^3+2x^2-x+4 
% \Arrow[tikz=-]{both are polynoms}\\
% g(x) & = 5x^2-5x+6
% \end{WithArrows}
% \right.$
%
%
% \interitem
% Unlike |{aligned}|, the environment |{WithArrows}| uses |\textstyle| by
% default.
%
% Once again, it's possible to change this behaviour with |\WithArrowsOptions|:
%
% \quad |\WithArrowsOptions{displaystyle}|.
%
%
% \smallskip
% The following example is composed with |{aligned}|:\par\nobreak
%
% \smallskip
% $\left\{
% \begin{aligned}
% \sum_{i=1}^n (x_i+1)^2  
% & = \sum_{i=1}^n (x_i^2 + 2x_i+1) \\
% & = \sum_{i=1}^n x_i^2 + 2 \sum_{i=1}^nx_i + n 
% \end{aligned}
% \right.$
%
%
% \medskip 
% The following is composed with |{WithArrows}[c,displaystyle]|. The results are
% strictly identical.\footnote{In versions of \pkg{amsmath} older than the
% 5~nov.~2016, a thin space was added on the left of an environment |{aligned}|.
% The new versions do not add this space and neither do
% |{WithArrows}|.}\par\nobreak
%
% \smallskip
% $\left\{
% \begin{WithArrows}[c,displaystyle]
% \sum_{i=1}^n (x_i+1)^2 
% & = \sum_{i=1}^n (x_i^2 + 2x_i+1) \\
% & = \sum_{i=1}^n x_i^2 + 2 \sum_{i=1}^nx_i + n 
% \end{WithArrows}
% \right.$
%
%
% \section{Arrows in nested environments}
%
% \label{NestedEnv}
%
% The environments |{WithArrows}| can be nested. In this case, the options given
% to the encompassing environment applies also to the inner ones (with logical
% exceptions for |interline|, |code-before| and |code-after|). The command |Arrow|
% can be used as usual in each environment |{WithArrows}|.
% 
% \begin{Verbatim}[formatcom=\small\color{gray}]
% $~emphase#\begin{WithArrows}@
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \Arrow{the numbers are real}\\
%   & \Leftrightarrow
%   \left\{~emphase#\begin{WithArrows}@[c]
%   x+2y & = 0 \\
%   2x+4y & = 0 
%   ~emphase#\end{WithArrows}@\right. \\
%   & \Leftrightarrow
%   \left\{~emphase#\begin{WithArrows}@[c]
%   x+2y & = 0 \Arrow[tikz=-]{the same equation}\\
%   x+2y & = 0 
%   ~emphase#\end{WithArrows}@\right. \\
%   & \Leftrightarrow x+2y=0 
% ~emphase#\end{WithArrows}@$
% \end{Verbatim}
%
% $\begin{WithArrows}
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \Arrow{the numbers are real}\\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   2x+4y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \Arrow[tikz=-]{the same equation}\\
%   x+2y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow x+2y=0 
% \end{WithArrows}$
%
% \bigskip
% However, one may want to draw an arrow between rows that are not in the same
% environment. For example, one may want to draw the following arrow :\par\nobreak
%
% \bigskip
% $\begin{WithArrows}[code-after = \Arrow[v]{1-2}{2-2}{division by $2$} ]
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   2x+4y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   x+2y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow x+2y=0 
% \end{WithArrows}$
%
%
% \bigskip
% Such a construction is possible by using |\Arrow| in the |code-after| option.
% Indeed, in |code-after|, a special version of |\Arrow| is available (we will
% call it ``|\Arrow| in |code-after|'').
%
% \smallskip
% A command |\Arrow| in |code-after| takes three arguments :
% \begin{itemize}[beginpenalty=10000]
% \item a specification of the start row of the arrow ;
% \item a specification of the end row of the arrow ;
% \item the label of the arrow.
% \end{itemize}
% As usual, it's also possible to give options within square brackets before or
% after the three arguments. However, these options are limited (see below).
% 
% \bigskip
% The specification of the row is constructed with the position of the concerned
% environment in the nesting tree, followed (after an hyphen) by the number of
% the row.
%
% \bigskip
% In the previous example, there are two environments |{WithArrows}| nested in
% the main environment |{WithArrows}|.
%
% $\begin{WithArrows}[tikz-code = {\path (#1) to node {#3} (#2) ; }]
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \\
%   & \Leftrightarrow \color{blue}
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \Arrow{environment number 1}\\
%   2x+4y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow \color{red}
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \Arrow{environment number 2}\\
%   x+2y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow x+2y=0 
% \end{WithArrows}$
%
% \bigskip
% The arrow we want to draw starts in the row~$2$ of the sub-environment
% number~$1$ (and therefore, the specification is |1-2|) and ends in the row~$2$
% of the sub-environment number~$2$ (and therefore, the specification is |2-2|).
% We can draw the arrow with the following command |\Arrow| in |code-after| :
% \begin{Verbatim}
% $\begin{WithArrows}[~emphase#code-after = \Arrow{1-2}{2-2}{division by $2$}@ ]
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \\
% .........
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}[code-after = \Arrow{1-2}{2-2}{division by $2$} ]
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   2x+4y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   x+2y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow x+2y=0 
% \end{WithArrows}$
% 
% \bigskip
% The options allowed for a command |\Arrow| in |code-after| are: |ll|, |lr|,
% |rl|, |rr|, |v|, |xoffset|, |tikz| and |tikz-code|. Except |v|, which is
% specific to |\Arrow| in |code-after|, all these options have their usual
% meaning.
%
% With the option |v|, the arrow drawn is vertical to an abscissa computed with
% the start row and the end row only : the intermediate lines are not taken into
% account unlike with the option |i|. Currently, the option |i| is not available
% for the command~|\Arrow| in |code-after|. However, it's always possible to
% translate an arrow with |xoffset| (or |xshift| of Tikz).
% \begin{Verbatim}
% $\begin{WithArrows}[code-after=\Arrow~emphase#[v]@{1-2}{2-2}{division by $2$}]
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \\
% .........
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}[code-after = \Arrow[v]{1-2}{2-2}{division by $2$} ]
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   2x+4y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   x+2y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow x+2y=0 
% \end{WithArrows}$
%
%  
% \interitem
% The package \pkg{witharrows} gives also another command available only in
% |code-after|: the command |\MultiArrow|. This command draws a ``rak''. The list
% of the rows of the environment concerned by this rak are given in the first
% argument of the command |\MultiArrow|. This list is given with the syntax of
% the list in a |\foreach| command of \pkg{pgffor}.
%
%
% \begin{Verbatim}
% $\begin{WithArrows}[tikz = rounded corners,
%                     code-after = {~emphase#\MultiArrow{1,...,4}{text}@} ]
% A & = B \\
%   & = C \\
%   & = D \\
%   & = E \\
%   & = F
% \end{WithArrows}$
% \end{Verbatim}
% 
% 
% $\begin{WithArrows}[tikz = rounded corners,
%                     code-after = {\MultiArrow{1,...,4}{text}}]
% A & = B \\
%   & = C \\
%   & = D \\
%   & = E \\
%   & = F
% \end{WithArrows}$
%
% \medskip
% As of now, there is no option available for the command |\MultiArrow| (maybe
% in a future release).
% 
% 
% \bigskip
% \section{Arrows from outside environments \{WithArrows\}}
%
% If someone wants to draw arrows from outside the environments |{WithArrows}|,
% he can use the Tikz nodes created in the environments.
% 
% The Tikz name of a node created by \pkg{witharrows} is prefixed by |wa-|.
% Then, we have a list of numbers which give the position in the nesting tree
% and the row number in the environment. At the end, we have the suffixe |l| for
% a ``left node'' and |r| for a ``right node''.
% 
% \smallskip
% For illustrative purposes, we give an example of nested environments
% |{WithArrows}|, and, for each ``right node'', the name of that
% node.\footnote{There is an option |show-node-names| to show the names of these
% nodes.}
% 
% \medskip
% \[\begin{WithArrows}[show-nodes,show-node-names]
% A & \vartriangleleft B+B+B+B+B+B+B+B+B+B+B+B+B \\
% & \vartriangleleft \left\{
% \begin{WithArrows}[c]
% C & \vartriangleleft D \\
% E & \vartriangleleft F 
% \end{WithArrows}
% \right. \\
%  & \vartriangleleft 
% \left\{
% \begin{WithArrows}[c]
% G & \vartriangleleft H+H+H+H+H+H+H \\
% I & \vartriangleleft 
% \left\{
% \begin{WithArrows}
% J &\vartriangleleft K \\
% L &\vartriangleleft M 
% \end{WithArrows}
% \right.
% \end{WithArrows}
% \right. \\
%  & \vartriangleleft 
% \left\{
% \begin{WithArrows}[c]
% N & \vartriangleleft O \\
% P & \vartriangleleft Q 
% \end{WithArrows}
% \right.
% \end{WithArrows}\]
%
% \medskip
% The package \pkg{witharrows} provides some tools facilitating the use of these
% nodes:
% \begin{itemize}[beginpenalty=10000]
% \item the command |\WithArrowsLastEnv| gives the number of the last
% environment of level~$0$ (\emph{i.e.} which is not included in another
% environment of the package \pkg{witharrows});
%
% \item a name can be given to a given environment with the option |name| and,
% in this case, the nodes created in the environment will have aliases
% constructed with this name;
%
% \item the Tikz style |WithArrows/arrow| is the style used by \pkg{witharrows}
% when drawing an arrow\footnote{More precisely, this style is given to the Tikz
% option ``|every path|'' before drawing the arrow with the code of the option
% |tikz-code|. This style is modified (in TeX scopes) by the option |tikz| of
% \pkg{witharrows}.};
%
% \item the Tikz style |WithArrows/arrow/tips| is the style for the tip of the
% arrow (loaded by |WithArrows/arrow|).
% \end{itemize}
%
% For example, we can draw an arrow from \texttt{wa-\WithArrowsLastEnv-2-1-2-r.south}
% to \texttt{wa-\WithArrowsLastEnv-3-2-r.north} with the following Tikz command. 
%
% \begin{Verbatim}
% \begin{tikzpicture}[remember picture,overlay]
% \draw [WithArrows/arrow] 
%       ([xshift=3mm]wa-\WithArrowsLastEnv-2-1-2-r.south)
%    to ([xshift=3mm]wa-\WithArrowsLastEnv-3-2-r.north) ;
% \end{tikzpicture}
% \end{Verbatim}
%
% \[\begin{WithArrows}
% A & \vartriangleleft B+B+B+B+B+B+B+B+B+B+B+B+B \\
% & \vartriangleleft \left\{
% \begin{WithArrows}[c]
% C & \vartriangleleft D \\
% E & \vartriangleleft F 
% \end{WithArrows}
% \right. \\
%  & \vartriangleleft 
% \left\{
% \begin{WithArrows}[c]
% G & \vartriangleleft H+H+H+H+H+H+H \\
% I & \vartriangleleft 
% \left\{
% \begin{WithArrows}
% J &\vartriangleleft K \\
% L &\vartriangleleft M 
% \end{WithArrows}
% \right.
% \end{WithArrows}
% \right. \\
%  & \vartriangleleft 
% \left\{
% \begin{WithArrows}[c]
% N & \vartriangleleft O \\
% P & \vartriangleleft Q 
% \end{WithArrows}
% \right.
% \end{WithArrows}\]
%
% \begin{tikzpicture}[remember picture,overlay]
% \draw [WithArrows/arrow] 
%       ([xshift=3mm]wa-\WithArrowsLastEnv-2-1-2-r.south)
%    to ([xshift=3mm]wa-\WithArrowsLastEnv-3-2-r.north) ;
% \end{tikzpicture}
%
% \medskip
% In this case, it would be easier to use a command |\Arrow| in |code-after| but
% this is an example to explain how the Tikz nodes created by \pkg{witharrows}
% can be used.
% 
% \bigskip
% In the following example, we create two environments |{WithArrows}| named
% ``|first|'' and ``|second|'' and we draw a line between a node of the first
% and a node of the second.
%
% \begin{Verbatim}
% $\begin{WithArrows}[~emphase#name=first@]
% A & = B \\
%   & = C 
% \end{WithArrows}$
%
% \bigskip
% $\begin{WithArrows}[~emphase#name=second@]
% A' & = B' \\
%    & = C'
% \end{WithArrows}$
%
% \begin{tikzpicture}[remember picture,overlay]
% \draw [WithArrows/arrow] 
%       ([xshift=3mm]~emphase#first@-1-r.south)
%    to ([xshift=3mm]~emphase#second@-1-r.north) ;
% \end{tikzpicture}
% \end{Verbatim}
% 
%
% \begin{center}
% $\begin{WithArrows}[name=first]
% A & = B \\
%   & = C 
% \end{WithArrows}$
% 
% \bigskip
% $\begin{WithArrows}[name=second]
% A' & = B' \\
%    & = C' 
% \end{WithArrows}$
% \end{center}
%
% \begin{tikzpicture}[remember picture,overlay]
% \draw [WithArrows/arrow] 
%       ([xshift=3mm]first-1-r.south)
%    to ([xshift=3mm]second-1-r.north) ;
% \end{tikzpicture}
% 
% \section{The environment \{DispWithArrows\}}
% \label{DispWithArrows}
% 
% As previously said, the environment |{WithArrows}| bears similarities with the
% environment |{aligned}| of \pkg{amsmath} (and |mathtools|). This extension also
% provides an environment |{DispWithArrows}| which is similar to the
% environments |{align}| and |{flalign}| of \pkg{amsmath}.
%
% \medskip
% The environment |{DispWithArrows}| must be used \emph{outside} math mode. Like
% |{align}|, it should be used in horizontal mode.
% \begin{Verbatim}
% \begin{~emphase#DispWithArrows@}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{~emphase#DispWithArrows@}
% \end{Verbatim}
% \begin{DispWithArrows}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{DispWithArrows}
%
% \medskip
% It's possible to use the command |\notag| (or |\nonumber|) to suppress a tag. 
% 
% It's possible to use the command |\tag| to put a special tag (e.g. $\star$).
%
% It's also possible to put a label to the line of an equation with the command
% |\label|.
% 
% These commands must be in the second column of the environment.
% \begin{Verbatim}
% \begin{DispWithArrows}
% A & = (a+1)^2 \Arrow{we expand} ~emphase#\notag@ \\
%   & = a^2 + 2a + 1 ~emphase#\tag{$\star$} \label{my-equation}@
% \end{DispWithArrows}
% \end{Verbatim}
% \begin{DispWithArrows}
% A & = (a+1)^2 \Arrow{we expand} \notag \\
%   & = a^2 + 2a + 1 \tag{$\star$} \label{my-equation}
% \end{DispWithArrows}
% A link to the equation \ref{my-equation}.\footnote{In this document, the
% references have been customized with |\labelformat{equation}{(#1)}| in the preamble.}
% 
% 
% \medskip
% If \pkg{amsmath} (or \pkg{mathtools}) is loaded, it's also possible to use
% |\tag*| which, as in \pkg{amsmath}, typesets the tag without the parentheses.
% For example, it's possible to use it to put the symbol |\square| of
% \pkg{amssymb}. This symbol is often used to mark the end of a
% proof.\footnote{Notice that the environment |{DispWithArrows}| is compatible
% with the command |\qedhere| of \pkg{amsthm}.}
% \begin{Verbatim}
% \begin{DispWithArrows}
% A & = (a+1)^2 \Arrow{we expand} \notag \\
%   & = a^2 + 2a + 1 ~emphase#\tag*{$\square$}@
% \end{DispWithArrows}
% \end{Verbatim}
% \begin{DispWithArrows}
% A & = (a+1)^2 \Arrow{we expand} \notag \\
%   & = a^2 + 2a + 1 \tag*{$\square$} 
% \end{DispWithArrows}
%
% \medskip
% It's also possible to suppress all the autogenerated numbers with the boolean
% option |notag| (or |nonumber|), at the global or environment level. There is
% also an environment |{DispWithArrows*}| which suppresses all these
% numbers.\footnote{Even in this case, it's possible to put a ``manual tag''
% with the command |\tag|.}
% \begin{Verbatim}
% \begin{~emphase#DispWithArrows*@}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{~emphase#DispWithArrows*@}
% \end{Verbatim}
% \begin{DispWithArrows*}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{DispWithArrows*}
%
% \medskip
% In fact, there is also another option |tagged-lines| which can be used to
% control the lines that will be tagged. The value of this option is a list of
% the numbers of the lines that must to be tagged. For example, with the option
% |tagged-lines = {first,3,last}|, only the first, the third and the last line
% of the environment will be tagged. There is also the special value |all| which
% means that all the lines will be tagged.
% \begin{Verbatim}
% \begin{DispWithArrows}[~emphase#tagged-lines = last@]
% A & = A_1 \Arrow{first stage} \\
%   & = A_2 \Arrow{second stage} \\
%   & = A_3 
% \end{DispWithArrows}
% \end{Verbatim}
% \begin{DispWithArrows}[tagged-lines = last]
% A & = A_1 \Arrow{first stage} \\
%   & = A_2 \Arrow{second stage} \\
%   & = A_3 
% \end{DispWithArrows}
%
% \bigskip
% With the option |fleqn|, the environment is composed flush left (in a way
% similar to the option |fleqn| of the standard classes of LaTeX). In this case,
% the left margin can be controlled with the option |mathindent| (with a name
% inspired by the parameter |\mathindent| of standard LaTeX). The initial value
% of this parameter is 25~pt.
%
% \begin{Verbatim}
% \begin{DispWithArrows}[~emphase#fleqn,mathindent = 1cm@]
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{DispWithArrows}
% \end{Verbatim}
% \begin{DispWithArrows}[fleqn,mathindent = 1cm]
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{DispWithArrows}
%
% \medskip
% \emph{Remark}: By design, the option |fleqn| of \pkg{witharrows} is
% independent of the option |fleqn| of LaTeX. Indeed, since the environments of
% \pkg{witharrows} are meant to be used with arrows on the right side, the user
% may want to use \pkg{witharrows} with the option |fleqn| (in order to have
% more space on the right of the equations for the arrows) while still centering
% the classical equations.
%
% \medskip
% If the option |leqno| is used as a class option, the labels will be composed
% on the left also for the environments |{DispWithArrows}| and
% |{DispWithArrows*}|.\footnote{The package \pkg{amsmath} has an option |leqno|
% but \pkg{witharrows}, of course, is not aware of that option: \pkg{witharrows}
% only checks the option |leqno| of the document class.}
%
% \medskip
% If the package \pkg{amsmath} is loaded, it's possible to use the command
% |\intertext| in the environments |{DispWithArrows}|. It's also possible to use
% the environment |{subequations}|. However, there is, for the environments
% |{DispWithArrows}|, an option |subequations| to encapsulate the environment in
% an environment |{subequations}|.
%
% \medskip
% In the following example, the key |{subequations}| is fixed by the command
% |\WithArrowsOptions|. Each environment |{DispWithArrows}| will be subnumerated
% (in the scope of the |\WithArrowsOptions|)
% \begin{Verbatim}
% ~emphase#\WithArrowsOptions{subequations}@
% First environment.
% \begin{DispWithArrows}
% A & = B \\
%   & = C 
% \end{DispWithArrows}
% Second environment.
% \begin{DispWithArrows}
% D & = E \\
%   & = F 
% \end{DispWithArrows}
% \end{Verbatim}
% %
% \begin{scope}
% \WithArrowsOptions{subequations}
% First environment.
% \begin{DispWithArrows}
% A & = B \\
%   & = C 
% \end{DispWithArrows}
% Second environment.
% \begin{DispWithArrows}
% D & = E \\
%   & = F 
% \end{DispWithArrows}
% \end{scope}
%
% \bigskip
% If there is not enough space to put the tag at the end of a line, there is no
% automatic positioning of the label on the next line (as in the environments of
% \pkg{amsmath}). However, in |{DispWithArrows}|, the user can use the command
% |\tagnextline| to manually require the composition of the tag on the following
% line.
% \begin{Verbatim}
% \begin{DispWithArrows}[displaystyle]
% S_{2(p+1)}
% & =\sum_{k=1}^{2(p+1)} (-1)^k k^2 \\
% & \smash[b]{=\sum_{k=1}^{2p}(-1)^kk
%    +(-1)^{2p+1}(2p+1)^2+(-1)^{2p+2}(2p+2)^2} ~emphase#\tagnextline@ \\
% &= S_{2p}-(2p+1)^2+(2p+2)^2\\
% &=p(2p+1)-(2p+1)^2+(2p+2)^2\\
% &= 2p^2+5p+3 
% \end{DispWithArrows}
% \end{Verbatim}
% \begin{center}
% \color{gray}\vrule%
% \begin{minipage}{275pt}\color{black}
% \begin{DispWithArrows}[displaystyle]
% S_{2(p+1)}
% & =\sum_{k=1}^{2(p+1)} (-1)^k k^2 \\
% & \smash[b]{=\sum_{k=1}^{2p}(-1)^kk^2+(-1)^{2p+1}(2p+1)^2+(-1)^{2p+2}(2p+2)^2}
% \tagnextline \\ 
% &= S_{2p}-(2p+1)^2+(2p+2)^2\\
% &= 2p^2+p-4p^2-4p-1+4p^2+8p+4\\
% &= 2p^2+5p+3 
% \end{DispWithArrows}
% \end{minipage}%
% \color{gray}\vrule
% \end{center}
% 
%
%
% \bigskip
% The environments |{DispWithArrows}| and |{DispWithArrows*}| provide an option
% |wrap-lines|. With this option, the lines of the label are automatically
% wrapped on the right.\footnotemark[\thefnnohyphen]\label{wrap-lines}
%
% \begin{Verbatim}
% \begin{DispWithArrows*}[displaystyle,~emphase#wrap-lines@]
% S_n
% & = \frac1n \Re \left(\sum_{k=0}^{n-1}\bigl(e^{i\frac{\pi}{2n}}\bigr)^k\right)
% \Arrow{sum of terms of a geometric progression of ratio $e^{i\frac{2\pi}n}$}\\
% & = \frac1n \Re \left( \frac{1-\bigl(e^{i\frac{\pi}{2n}}\bigr)^n}
%                             {1-e^{i\frac{\pi}{2n}}}\right)
% \Arrow{This line has been wrapped automatically.} \\
% & = \frac1n \Re \left(\frac{1-i}{1-e^{i\frac{\pi}{2n}}}\right) 
% \end{DispWithArrows*}
% \end{Verbatim}
% \begin{DispWithArrows*}[displaystyle,wrap-lines]
% S_n
% & = \frac1n \Re \left(\sum_{k=0}^{n-1}\bigl(e^{i\frac{\pi}{2n}}\bigr)^k\right)
% \Arrow{sum of terms of a geometric progression of ratio $e^{i\frac{2\pi}n}$}\\
% & = \frac1n \Re \left(
% \frac{1-\bigl(e^{i\frac{\pi}{2n}}\bigr)^n}{1-e^{i\frac{\pi}{2n}}} \right) 
% \Arrow{This line has been wrapped automatically.} \\
% & = \frac1n \Re \left(\frac{1-i}{1-e^{i\frac{\pi}{2n}}}\right) 
% \end{DispWithArrows*}
% 
% \bigskip
% The option |wrap-lines| doesn't apply to the environments |{WithArrows}|
% nested in an environment |{DispWithArrows}| or |{DispWithArrows*}|. However,
% it applies to the instructions |\Arrow| and |\MultiArrow| of the |code-after|
% of the environments |{DispWithArrows}| or |{DispWithArrows*}|.
% 
% \vspace{1cm}
% We have said that the environments |{DispWithArrows}| and |{DispWithArrows*}|
% should be used in horizontal mode and not in vertical mode. However, there is
% an exception. These environments can be used directly after a |\item| of a
% LaTeX list. In this case, no vertical space is added before the
% environment.\footnote{It's possible to disable this feature with the option |standard-behaviour-with-items|.}
%
% \medskip
% Here is an example. The use of |{DispWithArrows}| gives the ability to tag an
% equation (and also to use |wrap-lines|).
%
% \begin{Verbatim}
% ~emphase#\begin{enumerate}@
% ~emphase#\item @
% \begin{DispWithArrows}%
%   [displaystyle, wrap-lines, tagged-lines = last, fleqn, mathindent = 0 pt]
% S_n
% & = \frac1n \Re \left(\sum_{k=0}^{n-1}\bigl(e^{i\frac{\pi}{2n}}\bigr)^k\right)
% \Arrow{we use the formula for a sum of terms of a geometric progression of
% ratio $e^{i\frac{2\pi}n}$}\\ 
% & = \frac1n \Re \left( \frac{1-\bigl(e^{i\frac{\pi}{2n}}\bigr)^n}
%                             {1-e^{i\frac{\pi}{2n}}}\right)
% \Arrow{$\bigl(e^{i\frac{\pi}{2n}}\bigr)^n = e^{i\frac{\pi}2}=i$} \\
% & = \frac1n \Re \left(\frac{1-i}{1-e^{i\frac{\pi}{2n}}}\right) 
% \end{DispWithArrows}
% ~emphase#\end{enumerate}@
% \end{Verbatim}
% \begin{enumerate}
% \item 
% \begin{DispWithArrows}[displaystyle, wrap-lines, tagged-lines = last, fleqn, mathindent = 0 pt]
% S_n
% & = \frac1n \Re \left(\sum_{k=0}^{n-1}\bigl(e^{i\frac{\pi}{2n}}\bigr)^k\right)
% \Arrow{we use the formula for a sum of terms of a geometric progression of
% ratio $e^{i\frac{2\pi}n}$}\\ 
% & = \frac1n \Re \left(
% \frac{1-\bigl(e^{i\frac{\pi}{2n}}\bigr)^n}{1-e^{i\frac{\pi}{2n}}} \right) 
% \Arrow{$\bigl(e^{i\frac{\pi}{2n}}\bigr)^n = e^{i\frac{\pi}2}=i$} \\
% & = \frac1n \Re \left(\frac{1-i}{1-e^{i\frac{\pi}{2n}}}\right) 
% \end{DispWithArrows}
% \end{enumerate}
% 
% \vspace{1cm}
% The environment |{DispWithArrows}| is similar to the environment |{align}| of
% \pkg{amsmath}. However, |{DispWithArrows}| is not constructed upon |{align}|
% (in fact, it's possible to use \pkg{witharrows} without \pkg{amsmath}).
%
% There are differences between |{DispWithArrows}| and |{align}|. 
% \begin{itemize}[beginpenalty=10000]
% \item The environment |{DispWithArrows}| cannot be inserted in an environment
% |{gather}| of \pkg{amsmath}.
% \item An environment |{DispWithArrows}| is always unbreakable (even with
% |\allowdisplaybreaks| of \pkg{amsmath}).
% \item The commands |\label|, |\tag|, |\notag| and |\nonumber| are allowed only
% in the last column.
% \item After an |\item| of a LaTeX list, no vertical space is added (this can
% be changed with the option |standard-behaviour-with-items|).
% \item 
% \begin{bfseries}
% Last but not least, by default, the elements of a |\{DispWithArrows\}|
% are composed in |textstyle| and not in |displaystyle| (it's possible to change
% this point with the option |displaystyle|). 
% \end{bfseries}
% \end{itemize}
% 
% \bigskip 
% Concerning the references, the package \pkg{witharrows} is compatible with the
% extensions \pkg{autonum}, \pkg{cleveref}, \pkg{fancyref}, 
% \pkg{hyperref}, \pkg{listlbls}, \pkg{prettyref}, \pkg{refcheck},
% \pkg{refstyle}, \pkg{showlabels}, \pkg{smartref}, \pkg{typedref} and
% \pkg{varioref}, and with the options |showonlyrefs| and |showmanualtags| of
% \pkg{mathtools}.\footnote{We recall that \pkg{varioref}, \pkg{hyperref},
% \pkg{cleveref} and \pkg{autonum} must be loaded in this order. The package
% \pkg{witharrows} can be loaded anywhere.}
%
% It is not compatible with \pkg{showkeys} (not all the labels are shown).
%
% 
%
%
% \subsection{The option <...> of DispWithArrows}
%
% The environment |{DispWithArrows}| provides an option |left-brace|. When present,
% the value of this option is composed on the left, followed by a curly brace
% (hence the name) and the body of the environment.\footnote{The option
% |left-brace| can also be used without value: in this case, only the brace is drawn...}
%
% For lisibility, this option |left-brace| is also available with a special
% syntax: it's possible to give this option between angle brackets  
% (\verb|<| and \verb|>|) just after \verb|{DispWithArrows}| (before the optional
% arguments between square brackets).
%
% \bigskip 
% The following code is an example of multi-case equations.\footnote{The
% environment |{cases}| of \pkg{amsmath} is a way to compose such multi-cases
% equations. However, it's not possible to use the automatic numbering of
% equations with this environment. The environment |{numcases}| of the extension
% \pkg{cases} (written by Donald Arseneau) provides this possibility but, of
% course, it's not possible to draw arrows with this extension.}
%
% \medskip
%
% \begin{BVerbatim}
% \begin{DispWithArrows}~emphase#< \binom{n}{p} = >@[format = ll,fleqn,displaystyle]
% 0 & \quad \text{if } p > n  
% \Arrow{if fact, it's a special case\\ of the following one} \\
% \frac{n(n-1)\cdots(n-p+1)}{p!} & \quad \text{if } 0 \leq p \leq n  \\
% 0 & \quad \text{if } p < 0 
% \end{DispWithArrows}
% \end{BVerbatim}
% %
% \begin{DispWithArrows}< \binom{n}{p} = >[format = ll,fleqn,displaystyle]
% 0 & \quad \text{if } p > n  
% \Arrow{if fact, it's a special case\\ of the following one} \\
% \frac{n(n-1)\cdots(n-p+1)}{p!} & \quad \text{if } 0 \leq p \leq n  \\
% 0 & \quad \text{if } p < 0 
% \end{DispWithArrows}
%
% \interitem
% In the following example, we subnumerate the equations with the option
% |subequations| (available when the package \pkg{amsmath} is loaded).
%
% \begin{Verbatim}
% \begin{DispWithArrows}~emphase#< \label{system} \ref*{system} \Leftrightarrow >@[
%     format = l, subequations ]
% x+y+z = -3 \Arrow[tikz=-,jump=2]{3 equations} \\
% xy+xz+yz=-2 \\
% xyz = -15 \label{last-equation}
% \end{DispWithArrows}
% \end{Verbatim}
% %
% \begin{DispWithArrows}< \label{system} \ref*{system} \Leftrightarrow >[
%    format = l, subequations]
% x+y+z = -3 \Arrow[tikz=-,jump=2]{3 equations} \\
% xy+xz+yz=-2 \\
% xyz = -15 \label{last-equation} 
% \end{DispWithArrows}
%
%
% \bigskip
% The whole system is the equation \ref{system} (this reference has been coded
% by |\ref{system}|) whereas the last equation is the equation
% \ref{last-equation} (this reference has been coded by
% |\ref{last-equation}|). The command |\ref*| used in the code above is
% provided by \pkg{hyperref}. It's a variant of |\ref| which doesn't create 
% interactive link.
%
% \bigskip
% With the option \verb|replace-left-brace-by|, it's possible to replace the
% left curly brace by another extensible delimiter. For example,
% ``|replace-left-brace-by = [\enskip|'' will compose with a bracket and add also a
% |\enskip| after this bracket.
% 
% \bigskip
% \section{Advanced features}
%
% \subsection{Utilisation with plain-TeX}
% \label{plain-TeX}
%
% The extension \pkg{witharrows} can be used with plain-TeX. In this case, the
% extension must be loaded with |\input|:
% \begin{Verbatim}
% \input{witharrows}
% \end{Verbatim}
% 
% \medskip
% In plain-TeX, there is not environments as in LaTeX. Instead of using the
% environment |{Witharrows}|, with |\begin{WithArrows}| and |\end{WithArrows}|,
% one should use a pseudo-environment delimited by |\WithArrows| and
% |\endWithArrows| (idem for |{DispWithArrows}|).
%
% \begin{Verbatim}
% $\WithArrows
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \endWithArrows$
% \end{Verbatim}
%
% \medskip
% The version of \pkg{witharrows} for plain-TeX doesn't provide all the
% functionnalities of the LaTeX version. In particular, the functionnalities which
% deal with the number of the equations are not available (since they rely upon
% the system of tags of LaTeX).
%
% \subsection{The option tikz-code : how to change the shape of the arrows}
%
% \label{tikz-code}
%
% The option |tikz-code|\footnote{For historical reasons, the option |tikz-code|
% has an alias: |TikzCode|.} allows the user to change the shape of the 
% arrows.\footnote{If the option |wrap-lines| is used in an environment
% |{DispWithArrows}| or |{DispWithArrows*}|, the option |tikz-code| will have no
% effect for the arrows of this environment but only for the arrows in the
% nested environments |{WithArrows}|.}
%
% \smallskip
% For example, the options ``|up|'' and ``|down|'' described previously (cf.
% p.~\pageref{up-and-down}) are programmed internally with |tikz-code|.
% 
% \smallskip
% The value of this option must be a valid Tikz drawing instruction (with the
% final semicolon) with three markers |#1|, |#2| and |#3| for the start point,
% the end point and the label of the arrow.
%
% \bigskip
% By default, the value is the following:
% 
% \smallskip
% \qquad \verb|\draw (#1) to node {#3} (#2) ;|
%
%
% \bigskip
% In the following example, we replace this default path by a path with three
% segments (and the node overwriting the second segment).
% \begin{Verbatim}
% \begin{WithArrows}[format=c,ygap=5pt,interline=4mm,
%       ~emphase#tikz-code = {\draw[rounded corners]@
%       ~emphase#                  (~#1) -- ([xshift=5mm]~#1)@
%       ~emphase#                  -- node[circle,@
%       ~emphase#                          draw,@
%       ~emphase#                          auto = false,@
%       ~emphase#                          fill = gray!50,@
%       ~emphase#                          inner sep = 1pt] {\tiny ~#3}@ 
%       ~emphase#                  ([xshift=5mm]~#2)@
%       ~emphase#                  -- (~#2) ; }@]
% 3 (2x+4) = 6   \Arrow{$\div 3$} \\
% 2x+4 = 2       \Arrow{$-4$}     \\
% 2x = -2        \Arrow{$\div 2$} \\
%  x = -1
% \end{WithArrows}
% \end{Verbatim}
%
% 
% \[\begin{WithArrows}[format=c,
%       ygap=5pt,
%       interline=4mm,
%       tikz-code = {\draw[rounded corners]
%                         (#1) 
%                         --
%                         ([xshift=5mm]#1)
%                         -- node[circle,
%                                 draw,
%                                 auto=false,
%                                 fill=gray!50,
%                                 inner sep = 1pt] {\tiny #3} 
%                         ([xshift=5mm]#2)
%                         --
%                         (#2) ; }]
% 3 (2x+4) = 6   \Arrow{$\div 3$} \\
% 2x+4 = 2       \Arrow{$-4$}     \\
% 2x = -2        \Arrow{$\div 2$} \\
%  x = -1
% \end{WithArrows}\]
%
% \bigskip
% The environments |{DispWithArrows}| and its starred version
% |{DispWithArrows*}| provide a command |\WithArrowsRightX| which can be used in
% a definition of |tikz-code|. This command gives the $x$-value of the right side
% of the composition box (taking into account the eventual tags of the
% equations). For an example of use, see p.~\pageref{example-WithArrowsRightX}.
%
%
% \bigskip
% \subsection{The command \textbackslash WithArrowsNewStyle}
%
% The extension \pkg{witharrows} provides a command |\WithArrowsNewStyle| to
% define styles in a way similar to the ``styles'' of Tikz.
%
% The command |\WithArrowsNewStyle| takes two mandatory arguments. The first is
% the name of the style and the second is a list of key-value pairs. The scope
% of the definition done by |\WithArrowsNewStyle| is the current TeX scope.
%
% The style can be used as a key at the document level (with
% |\WithArrowsOptions|) or at the environment level (in the optional arguments
% of |{WithArrows}| and |{DispWithArrows}|). The style can also be used in
% another command |\WithArrowsNewStyle|.
%
% For an example of use, see p.~\pageref{example-WithArrowsRightX}.
%
%
% \bigskip
% \subsection{Vertical positioning of the arrows}
% 
% There are four parameters for fine tuning of the vertical positioning of the
% arrows : |ygap|, |ystart|, |start-adjust| and |end-adjust|.
% 
% \medskip
% We first explain the behaviour when the parameters |start-adjust| and
% |end-adjust| are equal to zero:
% \begin{itemize}[beginpenalty=10000]
% \item the option |ystart| sets the vertical distance between the base line of
% the text and the start of the arrow (initial value: 0.4 ex);
% \item the option |ygap| sets the vertical distance between two consecutive
% arrows (initial value: 0.4~ex).
% \end{itemize}
%
%
% \bigskip
% $\begin{WithArrows}[interline=1mm, adjust = 0pt]
%  (\cos x + \sin x)^2 & = \cos^2 x +2 \cos x \sin x + \sin^2 x\Arrow{}\tikz[remember picture] \coordinate (A) ; \\
%    & = \cos^2x + \sin^2x + 2\sin x\cos x \Arrow{} \\
%    & = 1 + \sin(2x) 
% \end{WithArrows}$
%
% \begin{tikzpicture}[remember picture,overlay,blue]
% \draw (wa-\WithArrowsLastEnv-1-r.south) to ++(1,0) coordinate (B) to ++(0.1,0) ;;
% \draw (A) to ++(1,0) coordinate (C) to ++(0.1,0) ;;
% \draw (B) -- (C) ;
% \draw[<-] (B) to ++(0,0.2) ;
% \draw[<-] (C) to ++(0,-0.2) ;
% \path (C) node[right=1mm] {|ystart|} ;
% \draw (wa-\WithArrowsLastEnv-2-r.north) to ++(3,0) coordinate (E) to ++(0.1,0);
% \draw (wa-\WithArrowsLastEnv-2-r.south) to ++(3,0) coordinate (F) to ++(0.1,0);
% \draw (E) -- (F) ;
% \draw[<-] (E) to ++(0,0.2) ;
% \draw[<-] (F) to ++(0,-0.2) ;
% \path (F) node[right=1mm] {|ygap|} ;
% \end{tikzpicture}
%
% \interitem 
% However, for aesthetic reasons, when it's possible, \pkg{witharrows} starts
% the arrow a bit higher (by an amount |start-adjust|) and ends the arrow a bit
% lower (by an amount |end-adjust|). By default, both parameters |start-adjust|
% and |end-adjust| are equal to $0.4$~ex.
%
% \bigskip
% Here is for example the behaviour without the mechanism of |start-adjust| and
% |end-adjust| (this was the standard behaviour for versions prior to 1.13).
% % \begin{Verbatim}
% $\begin{WithArrows}~emphase#[start-adjust=0pt, end-adjust=0pt]@
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1  
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}[start-adjust=0pt, end-adjust=0pt]
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1  
% \end{WithArrows}$
%
%
% \bigskip
% Here is the standard behaviour since version 1.13 (the parameters
% |start-adjust| and |end-ajust| are used with the initial value $0.4$~ex). The
% arrow is longer and the result is more aesthetic.
% 
% \medskip
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1  
% \end{WithArrows}$
%
%
% \bigskip
% It's also possible to use the option |adjust| which sets both |start-adjust|
% and |end-ajust|.
%
% \interitem
% Since the version 2.1 of \pkg{witharrows}, an arrow of |jump| equal to~$1$ has
% a maximal length\footnote{We call \emph{length} of an arrow the difference
% between the $y$-value of its start point and the $y$~value of its end point.}
% equal to the parameter |max-length-of-arrow|. The initial value of this
% parameter is $2$~cm.
% 
% In the following example, the value of |max-length-of-arrow| has been fixed to
% $1.5$~cm.
% \begin{Verbatim}
% \[\begin{WithArrows}[~emphase#max-length-of-arrow = 1.5cm@]
% A 
% & = 
% \begin{vmatrix}
% 1 & a & a^2 & a^3 & a^4 \\
% 1 & b & b^2 & b^3 & b^4 \\
% 1 & c & c^2 & c^3 & c^4 \\
% 1 & d & d^2 & d^3 & d^4 \\
% 1 & e & e^2 & e^3 & e^4 
% \end{vmatrix}
% \Arrow{
% $L_2 \gets L_2-L_1$ \\ 
% $L_3 \gets L_3-L_1$ \\ 
% $L_4 \gets L_4-L_1$ \\
% $L_5 \gets L_5-L_1$ % don't put \\ here
% } \\
% & = 
% \begin{vmatrix}
% 1 & a & a^2 & a^3 & a^4 \\
% 0 & b-a & b^2-a^2 & b^3-a^3 & b^4-a^4 \\
% 0 & c-a & c^2-a^2 & c^3-a^3 & c^4-a^4 \\
% 0 & d-a & d^2-a^2 & d^3-a^3 & d^4-a^4 \\
% 0 & e-a & e^2-a^2 & e^3-a^3 & e^4-a^4 
% \end{vmatrix}
% \end{WithArrows}\]
% \end{Verbatim}
%
%
% \bigskip
% \[\begin{WithArrows}[max-length-of-arrow = 1.5cm]
% A 
% & = 
% \begin{vmatrix}
% 1 & a & a^2 & a^3 & a^4 \\
% 1 & b & b^2 & b^3 & b^4 \\
% 1 & c & c^2 & c^3 & c^4 \\
% 1 & d & d^2 & d^3 & d^4 \\
% 1 & e & e^2 & e^3 & e^4 
% \end{vmatrix}
% \Arrow{
% $L_2 \gets L_2-L_1$ \\ 
% $L_3 \gets L_3-L_1$ \\ 
% $L_4 \gets L_4-L_1$ \\
% $L_5 \gets L_5-L_1$ 
% } \\
% & = 
% \begin{vmatrix}
% 1 & a & a^2 & a^3 & a^4 \\
% 0 & b-a & b^2-a^2 & b^3-a^3 & b^4-a^4 \\
% 0 & c-a & c^2-a^2 & c^3-a^3 & c^4-a^4 \\
% 0 & d-a & d^2-a^2 & d^3-a^3 & d^4-a^4 \\
% 0 & e-a & e^2-a^2 & e^3-a^3 & e^4-a^4 
% \end{vmatrix}
% \end{WithArrows}\]
%
% 
% \bigskip
% \subsection{Footnotes in the environments of witharrows}
% 
% If you want to put footnotes in an environment |{WithArrows}| or
% |{DispWithArrows}|, you can use a pair |\footnotemark|--|\footnotetext|.
%
% \smallskip
% It's also possible to extract the footnotes with the help of the package
% \pkg{footnote} or the package \pkg{footnotehyper}.
%
% \smallskip
% If \pkg{witharrows} is loaded with the option |footnote| (with
% |\usepackage[footnote]{witharrows}| or with |\PassOptionsToPackage|), the
% package \pkg{footnote} is loaded (if it is not yet loaded) and it is used to
% extract the footnotes.
%
% \smallskip
% If \pkg{witharrows} is loaded with the option |footnotehyper|, the package
% \pkg{footnotehyper} is loaded (if it is not yet loaded) ant it is used to
% extract footnotes.
%
% \smallskip
% Caution: The packages \pkg{footnote} and \pkg{footnotehyper} are incompatible.
% The package \pkg{footnotehyper} is the successor of the package \pkg{footnote}
% and should be used preferently. The package \pkg{footnote} has some drawbacks,
% in particular: it must be loaded after the package \pkg{xcolor} and it is not
% perfectly compatible with \pkg{hyperref}.
%
% \medskip
% In this document, the package \pkg{witharrows} has been loaded with the option
% |footnotehyper| and we give an example with a footnote in the label of an
% arrow:
%
% \smallskip
% $\begin{WithArrows}
% A & = (a+b)^2 
% \Arrow{We expand\,\footnote{A footnote.}} \\
%    & = a^2+b^2+2ab
% \end{WithArrows}$
%
% \bigskip
% \subsection{Option no-arrows}
%
% The option |no-arrows| is a convenience given to the user. With this option
% the arrows are not drawn. However, an analyse of the arrows is done and some
% errors can be raised, for example if an arrow would arrive after the last row
% of the environment.
%
%
% \bigskip
% \subsection{Note for developpers}
%
% If you want to construct an environment upon an environment of
% \pkg{witharrows}, we recommand to call the environment with the construction
% |\WithArrows|-|\endWithArrows| or |\DispWithArrows|-|\endDispWithArrows| (and
% not |\begin{WithArrows}|-|\end{WithArrows}|, etc.).
%
% \smallskip
% By doing so, the error messages generated by \pkg{witharrows} will (usually)
% mention the name of your environment and they will be easier to understand by
% the final user.
%
% \smallskip
% By example, you can define an environment |{DWA}| which is an alias of
% |{DispWithArrows}|:
% \begin{BVerbatim}
% \NewDocumentEnvironment {DWA} {} {\DispWithArrows}{\endDispWithArrows}
% \end{BVerbatim}
% 
% \smallskip
% If you use this environment |{DWA}| in math mode, you will have the following
% error message:
% 
% \begin{BVerbatim}
% The environment {DWA} should be used only outside math mode.
% \end{BVerbatim}
% 
% \interitem
% Another example is the definition of the environment |{DispWithArrows*}|
% internally in the package \pkg{witharrows} by the following code:
% \begin{Verbatim}
% \NewDocumentEnvironment {DispWithArrows*} {}
%     {\WithArrowsOptions{notag}%
%      \DispWithArrows}
%     {\endDispWithArrows}
% \end{Verbatim}
%
%
%
% \section{Examples}
%
% \subsection{\textbackslash MoveEqLeft}
%
% It's possible to use |\MoveEqLeft| of \pkg{mathtools}. Don't forget that
% |\MoveEqLeft| has also the value of an ampersand (|&|). That's important for the
% placement of an eventual command |\Arrow|.
% 
% 
% 
% \begin{Verbatim}[formatcom=\small\color{gray}]
% $\begin{WithArrows}[interline=0.5ex]
% ~emphase#\MoveEqLeft@ \arccos(x) = \arcsin \frac45 + \arcsin \frac5{13} 
% \Arrow{because both are in $[-\frac{\pi}2,\frac{\pi}2]$} \\
% & \Leftrightarrow x = \sin\left(\arcsin\frac45 + \arcsin\frac5{13}\right) \\
% & \Leftrightarrow x = \frac45\cos\arcsin\frac5{13} + \frac5{13} \cos\arcsin\frac45 
% \Arrow{$\forall x \in [-1,1], \cos(\arcsin x) = \sqrt{1-x^2}$} \\
% & \Leftrightarrow x = \frac45\sqrt{1-\bigl(\frac5{13}\bigr)^2}
% + \frac5{13}\sqrt{1-\bigl(\frac45\bigr)^2} 
% \end{WithArrows}$
% \end{Verbatim}
%
%
% \medskip
% $\begin{WithArrows}[interline=0.5ex]
% \MoveEqLeft \arccos(x) = \arcsin \frac45 + \arcsin \frac5{13} 
% \Arrow{because both are in $[-\frac{\pi}2,\frac{\pi}2]$} \\
% & \Leftrightarrow x = \sin\left(\arcsin\frac45 + \arcsin\frac5{13}\right) \\
% & \Leftrightarrow x = \frac45\cos\arcsin\frac5{13} + \frac5{13} \cos\arcsin\frac45 
% \Arrow{$\forall x \in [-1,1], \cos(\arcsin x) = \sqrt{1-x^2}$} \\
% & \Leftrightarrow x = \frac45\sqrt{1-\bigl(\frac5{13}\bigr)^2}
% + \frac5{13}\sqrt{1-\bigl(\frac45\bigr)^2} 
% \end{WithArrows}$
%
%
% \bigskip
% \subsection{Modifying the shape of the nodes}
%
% It's possible to change the shape of the labels, which are Tikz nodes, by
% modifying the key ``|every node|'' of Tikz.
%
% \begin{Verbatim}
% \begin{WithArrows}%
%      [format = c,
%       interline = 4mm,
%       tikz = {~emphase#every node/.style = {circle,@
%               ~emphase#                     draw,@
%               ~emphase#                     auto = false,@
%               ~emphase#                     fill = gray!50,@
%               ~emphase#                     inner sep = 1pt,@
%               ~emphase#                     font = \tiny}@}]
%  3 (2x+4) = 6 \Arrow{$\div 3$} \\
%  2x+4 = 2     \Arrow{$-4$} \\
%  2x = -2      \Arrow{$\div 2$} \\
%  2x = -1
% \end{WithArrows}
% \end{Verbatim}
%
% \[\begin{WithArrows}[%
%       format = c,
%       interline = 4mm,
%       tikz = {every node/.style = {circle,
%                                    draw,
%                                    auto = false,
%                                    fill = gray!50,
%                                    inner sep = 1pt,
%                                    font = \tiny}}]
%  3 (2x+4) = 6 \Arrow{$\div 3$} \\
%  2x+4 = 2     \Arrow{$-4$}     \\
%  2x = -2      \Arrow{$\div 2$} \\
%  2x = -1
% \end{WithArrows}\]
%
%
% \bigskip
% \subsection{Examples with the option tikz-code}
%
% We recall that the option |tikz-code| is the Tikz code used by \pkg{witharrows}
% to draw the arrows.\footnote{If an environment |{DispWithArrows}| or
% |{DispWithArrows*}| is used with the option |wrap-lines|, the value of the
% option |tikz-code| is not used for this environment (but is used for the
% environments nested inside).}
%
% \smallskip
% The value by defaut of |tikz-code| is \verb|\draw (#1) to node {#3} (#2) ;|
% where the three markers |#1|, |#2| and |#3| represent the start row, the end
% row and the label of the arrow.
%
%
% \bigskip
% \subsubsection{Example 1}
% In the following example, we define the value of |tikz-code| with two
% instructions |\path| : the first instruction draws the arrow itself and the
% second puts the label in a Tikz node in the rectangle delimited by the arrow.
%
% \begin{Verbatim}
% \begin{DispWithArrows*}%
%       [displaystyle,
%        ygap = 2mm,
%        ystart = 0mm,
%        ~emphase#tikz-code = {\draw (~#1) -- ++(4.5cm,0) |- (~#2) ;@
%        ~emphase#             \path (~#1) -- (~#2) @
%        ~emphase#                    node[text width = 4.2cm, right, midway] {~#3} ;}@]
% S_n
% & = \frac1n \sum_{k=0}^{n-1}\cos\bigl(\tfrac{\pi}2\cdot\tfrac kn\bigr)
% ...........
% \end{Verbatim}
%
%
% \bigskip
% \begin{DispWithArrows*}[
%        displaystyle,
%        ygap = 2mm,
%        ystart = 0mm,
%        tikz-code = {\draw (#1) -- ++(4.5cm,0) |- (#2) ;
%                     \path (#1) -- (#2) 
%                            node[text width = 4.2cm, right, midway] {#3} ;}]
% S_n
% & = \frac1n \sum_{k=0}^{n-1}\cos\bigl(\tfrac{\pi}2\cdot\tfrac kn\bigr)
% \Arrow{$\cos x = \Re(e^{ix})$}\\
% & = \frac1n\sum_{k=0}^{n-1} \Re\left(e^{i\frac{k\pi}{2n}}\right)
% \Arrow{$\Re(z+z')=\Re(z)+\Re(z')$}\\
% & = \frac1n \Re\left(\sum_{k=0}^{n-1} e^{i\frac{k\pi}{2n}}\right)
% \Arrow{$\exp$ is a morphism for $\times$ et $+$} \\
% & = \frac1n \Re \left(\sum_{k=0}^{n-1}\bigl(e^{i\frac{\pi}{2n}}\bigr)^k\right)
% \Arrow{sum of terms of a geometric progression of ratio $e^{i\frac{2\pi}n}$}\\
% & = \frac1n \Re \left( \frac{1-\bigl(e^{i\frac{\pi}{2n}}\bigr)^n}{1-e^{i\frac{\pi}{2n}}}\right)\\
% & = \frac1n \Re \left(\frac{1-i}{1-e^{i\frac{\pi}{2n}}}\right) 
% \end{DispWithArrows*}
%
% \bigskip
% \subsubsection{Example 2}
%
% \label{example-WithArrowsRightX}
% It's possible to modify the previous example to have the ``|text width|''
% automatically computed with the right margin (in a way similar as the
% |wrap-lines| option) in the environments |{DispWithArrows}| and
% |{DispWithArrows*}|. In the definition of |tikz-code|, we use the command
% |\WithArrowsRightX| which is the $x$-value of the right margin of the current
% composition box (it's a TeX command and not a dimension). For lisibility, we
% use a style. This example requires the Tikz library \pkg{calc}.
%
% \begin{Verbatim}
% \WithArrowsNewStyle{MyStyle}       
%   {displaystyle,
%    ygap = 2mm,
%    xoffset = 0pt,
%    ystart = 0mm,
%    tikz-code = {\path let \p1 = (~#~#1)
%                       in (~#~#1)
%                           -- node [anchor = west, 
%                                    text width = {~emphase#\WithArrowsRightX@ - \x1 - 0.5 em}] 
%                                   {~#~#3} 
%                          (~#~#2) ;
%                 \draw let \p1 = (~#~#1) 
%                       in (~#~#1) -- ++(~emphase#\WithArrowsRightX@ - \x1,0) |- (~#~#2) ; }}
% \end{Verbatim}
%
% \begin{Verbatim}
%\begin{DispWithArrows}[MyStyle]
%   S_n
%   & = \frac1n \sum_{k=0}^{n-1}\cos\bigl(\tfrac{\pi}2\cdot\tfrac kn\bigr)
%   \Arrow{$\cos x = \Re(e^{ix})$}\\
% ...........
% \end{Verbatim}
% 
% \WithArrowsNewStyle{MyStyle}       
% {displaystyle,
%  ygap = 2mm,
%  xoffset = 0pt,
%  ystart = 0mm,
%  tikz-code = {\path let \p1 = (##1)
%                     in (##1)
%                         -- node [anchor = west, 
%                                  text width = {\WithArrowsRightX - \x1 - 0.5 em}] {##3} 
%                        (##2) ;
%               \draw let \p1 = (##1) 
%                     in (##1) -- ++(\WithArrowsRightX - \x1,0) |- (##2) ; }}
%
%\begin{DispWithArrows}[MyStyle]
% S_n
% & = \frac1n \sum_{k=0}^{n-1}\cos\bigl(\tfrac{\pi}2\cdot\tfrac kn\bigr)
% \Arrow{$\cos x = \Re(e^{ix})$}\\
% & = \frac1n\sum_{k=0}^{n-1} \Re\left(e^{i\frac{k\pi}{2n}}\right)
% \Arrow{$\Re(z+z')=\Re(z)+\Re(z')$}\\
% & = \frac1n \Re\left(\sum_{k=0}^{n-1} e^{i\frac{k\pi}{2n}}\right)
% \Arrow{$\exp$ is a morphism for $\times$ et $+$} \\
% & = \frac1n \Re \left(\sum_{k=0}^{n-1}\bigl(e^{i\frac{\pi}{2n}}\bigr)^k\right)
% \Arrow{sum of terms of a geometric progression of ratio $e^{i\frac{2\pi}n}$}\\
% & = \frac1n \Re \left( \frac{1-\bigl(e^{i\frac{\pi}{2n}}\bigr)^n}{1-e^{i\frac{\pi}{2n}}}\right)\\
% & = \frac1n \Re \left(\frac{1-i}{1-e^{i\frac{\pi}{2n}}}\right) 
% \end{DispWithArrows}
% 
%
% 
% \bigskip
% \subsubsection{Example 3}
% 
% In the following example, we change the shape of the arrow depending on whether
% the start row is longer than the end row or not. This example requires the
% Tikz library \pkg{calc}.
% 
% \begin{Verbatim}
% \begin{WithArrows}[ll,interline=5mm,xoffset=5mm,
%       ~emphase#tikz-code  = {\draw[rounded corners,@
%       ~emphase#                    every node/.style = {circle,@
%       ~emphase#                                         draw,@
%       ~emphase#                                         auto = false,@
%       ~emphase#                                         inner sep = 1pt,@
%       ~emphase#                                         fill = gray!50,@
%       ~emphase#                                         font = \tiny }]@ 
%       ~emphase#                    let \p1 = (~#1),@
%       ~emphase#                        \p2 = (~#2)@
%       ~emphase#                    in \ifdim \x1 > \x2@
%       ~emphase#                         (\p1) -- node {~#3} (\x1,\y2) -- (\p2)@
%       ~emphase#                       \else@
%       ~emphase#                         (\p1) -- (\x2,\y1) -- node {~#3} (\p2)@
%       ~emphase#                       \fi ;}@]
% E & \Longleftrightarrow \frac{(x+4)}3 + \frac{5x+3}5 = 7 
% \Arrow{$\times 15$}\\
%   & \Longleftrightarrow 5(x+4) + 3(5x+3) = 105 \\
%   & \Longleftrightarrow 5x+20 + 15x+9 = 105 \\
%   & \Longleftrightarrow 20x+29 = 105 
% \Arrow{$-29$}\\
%   & \Longleftrightarrow 20x = 76 
% \Arrow{$\div 20$}\\
%   & \Longleftrightarrow x = \frac{38}{10} 
% \end{WithArrows}
% \end{Verbatim}
%
%
% \[\begin{WithArrows}[ll,interline=5mm,xoffset=5mm,
%       tikz-code  = {\draw[rounded corners,
%                           every node/.style = {circle,
%                                                draw,
%                                                auto = false,
%                                                inner sep = 1pt,
%                                                fill = gray!50,
%                                                font = \tiny}] 
%                           let \p1 = (#1),
%                               \p2 = (#2)
%                           in \ifdim \x1 > \x2
%                                (\p1) -- node {#3} (\x1,\y2) -- (\p2)
%                              \else
%                                (\p1) -- (\x2,\y1) -- node {#3} (\p2)
%                              \fi ;}]
% E & \Longleftrightarrow \frac{(x+4)}3 + \frac{5x+3}5 = 7 
% \Arrow{$\times 15$}\\
%   & \Longleftrightarrow 5(x+4) + 3(5x+3) = 105 \\
%   & \Longleftrightarrow 5x+20 + 15x+9 = 105 \\
%   & \Longleftrightarrow 20x+29 = 105 
% \Arrow{$-29$}\\
%   & \Longleftrightarrow 20x = 76 
% \Arrow{$\div 20$}\\
%   & \Longleftrightarrow x = \frac{38}{10} 
% \end{WithArrows}\]
%
%
% 
% \subsection{Automatic numbered loop}
%
% Assume we want to draw a loop of numbered arrows. In this purpose, it's
% possible to write a dedicated command |\NumberedLoop| which will do the job
% when used in |code-after|. In the following example, we write this command with
% |\NewDocumentCommand| of \pkg{xparse} and |\foreach| of \pkg{pgffor} (both
% packages are loaded when \pkg{witharrows} is loaded).
%
% \begin{Verbatim}
% \NewDocumentCommand \NumberedLoop {}
%         {\foreach \j in {2,...,\WithArrowsNbLines} 
%               { \pgfmathtruncatemacro{\i}{\j-1}
%                 \Arrow[rr]{\i}{\j}{\i} }
%          \Arrow[rr,xoffset=1cm,tikz=<-]{1}{\WithArrowsNbLines}{\WithArrowsNbLines}}
% \end{Verbatim}
% 
% The command |\WithArrowsNbLines| is a command available in |code-after| which
% gives the total number of lines (=rows) of the current environment (it's a
% command and not a counter).
%
%
% \bigskip
% \begin{Verbatim}
% $\begin{WithArrows}[~emphase#code-after = \NumberedLoop@]
% a.\;& f \text{ est continuous on } E \\
% b.\;& f \text{ est continuous in } 0 \\
% c.\;& f \text{ is bounded on the unit sphere} \\
% d.\;& \exists K > 0\quad \forall x \in E\quad \|f(x)\| \le K \|x\| \\
% e.\;& f \text{ is lipschitzian} 
% \end{WithArrows}$
% \end{Verbatim}
% 
% \bigskip
% \begin{scope}
% \NewDocumentCommand \NumberedLoop {}
%         {\foreach \j in {2,...,\WithArrowsNbLines} 
%               { \pgfmathtruncatemacro{\i}{\j-1}
%                 \Arrow[rr]{\i}{\j}{\i} }
%          \Arrow[rr,xoffset=1cm,tikz=<-]{1}{\WithArrowsNbLines}{\WithArrowsNbLines}}
%
%
% $\begin{WithArrows}[code-after = \NumberedLoop]
% a.\;& f \text{ est continuous on } E \\
% b.\;& f \text{ est continuous in } 0 \\
% c.\;& f \text{ is bounded on the unit sphere} \\
% d.\;& \exists K > 0\quad \forall x \in E\quad \|f(x)\| \le K \|x\| \\
% e.\;& f \text{ is lipschitzian} 
% \end{WithArrows}$
%
%
% \bigskip
% As usual, it's possible to change the characteristic of both arrows and nodes
% with the option |tikz|. However, if we want to change the style to have, for
% example, numbers in round brackets, the best way is to change the value of
% |tikz-code|:
%
% \begin{Verbatim}
% tikz-code = {\draw (~#1) to node {\footnotesize (~#3)} (~#2) ;}
% \end{Verbatim}
%
% \WithArrowsOptions{tikz-code = {\draw (#1) to node {\footnotesize (#3)} (#2) ;}}
%
% $\begin{WithArrows}[code-after = \NumberedLoop]
% a.\;& f \text{ est continuous on } E \\
% b.\;& f \text{ est continuous in } 0 \\
% c.\;& f \text{ is bounded on the unit sphere} \\
% d.\;& \exists K > 0\quad \forall x \in E\quad \|f(x)\| \le K \|x\| \\
% e.\;& f \text{ is lipschitzian}  
% \end{WithArrows}$
%
% \end{scope}
%
% \vspace{2cm}
% 
% \section{Implementation}
%
% \subsection{Declaration of the package and extensions loaded}
%
%
% First, \pkg{tikz} and some Tikz libraries are loaded before the
% |\ProvidesExplPackage|. They are loaded this way because |\usetikzlibrary| in
% |expl3| code fails.\footnote{cf.
%   |tex.stackexchange.com/questions/57424/using-of-usetikzlibrary-in-an-expl3-package-fails|}
%
% <@@=witharrows>
% 
%    \begin{macrocode}
%<*LaTeX>
\RequirePackage{tikz}
\RequirePackage{expl3}[2019/07/01]
%</LaTeX>
%<*plain-TeX>
\input tikz.tex
\input expl3-generic.tex
%</plain-TeX>
\usetikzlibrary{arrows.meta,bending}
%    \end{macrocode}
%
% \bigskip
% Then, we can give the traditional declaration of a package written with
% |expl3|:
%    \begin{macrocode}
%<*LaTeX>
\RequirePackage{l3keys2e}
\ProvidesExplPackage
  {witharrows}
  {\myfiledate}
  {\myfileversion}
  {Draws arrows for explanations on the right}
%    \end{macrocode}
%
% \bigskip
% The package \pkg{xparse} will be used to define the environments
% |{WithArrows}|, |{DispWithArrows}|, |{DispWithArrows*}| and the commands
% |\Arrow|, |\WithArrowsOptions| and |\WithArrowsNewStyle|.
%    \begin{macrocode}
\RequirePackage { xparse } [ 2019-01-01 ]
%</LaTeX>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*plain-TeX>
\ExplSyntaxOn
\catcode `\@ = 11
%</plain-TeX>
%    \end{macrocode}
%
% \bigskip
% \subsection{The packages footnote and footnotehyper}
%
% A few options can be given to the package \pkg{witharrows} when it is loaded
% (with |\usepackage|, |\RequirePackage| or |\PassOptionsToPackage|). Currently
% (version \myfileversion), there are two such options: |footnote| and
% |footnotehyper|. With the option |footnote|, \pkg{witharrows} loads
% \pkg{footnote} and uses it to extract the footnotes from the environments
% |{WithArrows}|. Idem for the option |footnotehyper|.
%
% \medskip
% The boolean |\g_@@_footnotehyper_bool| will indicate if the option
% |footnotehyper| is used.
%    \begin{macrocode}
%<*LaTeX>
\bool_new:N \g_@@_footnotehyper_bool
%    \end{macrocode}
%
% \medskip
% The boolean |\g_@@_footnote_bool| will indicate if the option |footnote| is
% used, but quicky, it will also be set to |true| if the option |footnotehyper|
% is used.
%    \begin{macrocode}
\bool_new:N \g_@@_footnote_bool
%</LaTeX>
%    \end{macrocode}
%
% \bigskip
%    \begin{macrocode}
\cs_new_protected:Npn \@@_msg_new:nn { \msg_new:nnn { witharrows } }
\cs_new_protected:Npn \@@_msg_new:nnn { \msg_new:nnnn { witharrows } }
\cs_new_protected:Npn \@@_msg_redirect_name:nn 
  { \msg_redirect_name:nnn { witharrows } }
\cs_new_protected:Npn \@@_error:n { \msg_error:nn { witharrows } }
\cs_new_protected:Npn \@@_warning:n { \msg_warning:nn { witharrows } }
\cs_new_protected:Npn \@@_fatal:n { \msg_fatal:nn { witharrows } }
\cs_new_protected:Npn \@@_error:nn  { \msg_error:nnn { witharrows } }
\cs_generate_variant:Nn \@@_error:nn { n x }
%    \end{macrocode}
% 
% \medskip
% We define a set of keys |WithArrows/package| for these options.
%    \begin{macrocode}
%<*LaTeX>
\keys_define:nn { WithArrows / package }
  { 
    footnote .bool_gset:N = \g_@@_footnote_bool ,
    footnotehyper .bool_gset:N = \g_@@_footnotehyper_bool ,
    unknown .code:n = 
      \@@_fatal:n { Option~unknown~for~package } 
  }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nn { Option~unknown~for~package }
  { 
    You~can't~use~the~option~'\l_keys_key_tl'~when~loading~the~
    package~witharrows.~Try~to~use~the~command~
    \token_to_str:N\WithArrowsOptions. 
  }
%    \end{macrocode}
%
%
% \bigskip
% We process the options when the package is loaded (with |\usepackage|).
%    \begin{macrocode}
\ProcessKeysOptions { WithArrows / package }
%    \end{macrocode}
% 
%
% \medskip
%    \begin{macrocode}
\@@_msg_new:nn { Option~incompatible~with~Beamer }
  { 
    The~option~'\l_keys_key_tl'\ is~incompatible~
    with~Beamer~because~Beamer~has~its~own~system~to~extract~footnotes.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { footnote~with~footnotehyper~package }
  { 
    You~can't~use~the~option~'footnote'~because~the~package~
    footnotehyper~has~already~been~loaded.~
    If~you~want,~you~can~use~the~option~'footnotehyper'~and~the~footnotes~  
    within~the~environments~of~witharrows~will~be~extracted~with~the~tools~
    of~the~package~footnotehyper.\\
    If~you~go~on,~the~package~footnote~won't~be~loaded.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { footnotehyper~with~footnote~package }
  { 
    You~can't~use~the~option~'footnotehyper'~because~the~package~
    footnote~has~already~been~loaded.~
    If~you~want,~you~can~use~the~option~'footnote'~and~the~footnotes~  
    within~the~environments~of~witharrows~will~be~extracted~with~the~tools~
    of~the~package~footnote.\\ 
    If~you~go~on,~the~package~footnotehyper~won't~be~loaded.
  }
%    \end{macrocode}
%
% \medskip
%    \begin{macrocode}
\bool_if:NT \g_@@_footnote_bool 
  { 
    \@ifclassloaded { beamer }
      { \msg_info:nn { witharrows } { Option~incompatible~with~Beamer } }
      { 
        \@ifpackageloaded { footnotehyper }
          { \@@_error:n { footnote~with~footnotehyper~package } }
          { \usepackage { footnote } }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\bool_if:NT \g_@@_footnotehyper_bool 
  { 
    \@ifclassloaded { beamer }
      { \@@_info:n  { Option~incompatible~with~Beamer } }
      { 
        \@ifpackageloaded { footnote }
          { \@@_error:n { footnotehyper~with~footnote~package } }
          { \usepackage { footnotehyper } }
      }
    \bool_gset_true:N \g_@@_footnote_bool 
  }
%    \end{macrocode}
% The flag |\g_@@_footnote_bool| is raised and so, we will only have to test
% |\g_@@_footnote_bool| in order to know if we have to insert an environment
% |{savenotes}| (the |\begin{savenotes}| is in |\@@_pre_halign:n| and
% |\end{savenotes}| at the end of the environments |{WithArrows}| and
% |{DispWithArrows}|).
%
% \bigskip
% \subsection{The class option leqno}
%
% The boolean |\c_@@_leqno_bool| will indicate if the class option |leqno| is
% used. When this option is used in LaTeX, the command |\@eqnnum| is redefined
% (as one can see in the file |leqno.clo|). That's enough to put the labels on
% the left in our environments |{DispWithArrows}| and |{DispWithArrows*}|.
% However, that's not enough when our option |wrap-lines| is used. That's why we
% have to know if this option is used as a class option. With the following
% programmation, |leqno| \emph{can't} be given as an option of \pkg{witharrows}
% (by design).
%    \begin{macrocode}
\bool_new:N \c_@@_leqno_bool
\DeclareOption { leqno } { \bool_set_true:N \c_@@_leqno_bool }
\DeclareOption* { }
\ProcessOptions* 
%</LaTeX>
%    \end{macrocode}
%
% 
%
% \bigskip
% \subsection{Some technical definitions}
%
% 
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_put_right:Nn { N v }
\cs_generate_variant:Nn \seq_set_split:Nnn { N x x }
%    \end{macrocode}
% 
% \medskip
% We create booleans in order to know if some packages are loaded. For example,
% for the package \pkg{amsmath}, the boolean is called
% |\c_@@_amsmath_loaded_bool|.\footnote{It's not possible to use
%   |\@ifpackageloaded| in the core of the functions because |\@ifpackageloaded|
%   is available only in the preamble.}
%    \begin{macrocode}
\AtBeginDocument 
  { 
    \clist_map_inline:nn
      { 
        amsmath, amsthm, autonum, cleveref, hyperref, mathtools, showlabels,
        typedref, unicode-math, varwidth 
      }
      {
        \bool_new:c { c_@@_#1_loaded_bool }
%<*LaTeX>
        \@ifpackageloaded { #1 }
          { \bool_set_true:c { c_@@_#1_loaded_bool } }
          { } 
%</LaTeX>
%<*plain-TeX>
        \bool_set_false:c { c_@@_#1_loaded_bool }
%</plain-TeX>
      }
  }
%    \end{macrocode}
%
% \bigskip
% We define a command |\@@_strcmp:nn| to compare two token lists. It will be
% available whether the engine is pdfTeX, XeTeX or LuaTeX.
%    \begin{macrocode}
\sys_if_engine_luatex:TF
  { 
    \cs_new_protected:Npn \@@_strcmp:nn  #1 #2
      { \lua_now:e { l3kernel.strcmp('#1','#2') } } 
  }
  { 
    \cs_new_protected:Npn \@@_strcmp:nn #1 #2 
      { \tex_strcmp:D { #1 } { #2 } } 
  } 
%    \end{macrocode}
%
% \bigskip
% We can now define a command |\@@_sort_seq:N| which will sort a sequence.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_seq:N #1
  { 
    \seq_sort:Nn #1
      { 
        \int_compare:nNnTF 
          { 
            \@@_strcmp:nn 
              { \str_lower_case:n { ##1 } } 
              { \str_lower_case:n { ##2 } } 
          } 
          > 0
          \sort_return_swapped:
          \sort_return_same:    
      } 
  }
%    \end{macrocode}
% 
% \bigskip
% The following command converts each item of a sequence from |tl| to |str|. It
% will be used when creating list of keys (a key name is always a |str|).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_convert_to_str_seq:N #1
  {
    \seq_clear:N \l_tmpa_seq
    \seq_map_inline:Nn #1 
      {
        \seq_put_left:Nx \l_tmpa_seq { \tl_to_str:n { ##1 } }
      }
    \seq_set_eq:NN #1 \l_tmpa_seq
  }
\cs_new_protected:Npn \@@_set_seq_of_str_from_clist:Nn #1 #2
  {
    \seq_set_from_clist:Nn #1 { #2 }
    \@@_convert_to_str_seq:N #1
  }
%    \end{macrocode}
% 
% \bigskip
% The command |\@@_save:N| saves a \pkg{expl3} variable by creating a global
% version of the variable. For a variable named |\l_|\texttt{\slshape
%   name}|_|\texttt{\slshape type}, the corresponding global variable will be
% named |\g_|\texttt{\slshape name}|_|\texttt{\slshape type}. The type of the
% variable is determinated by the suffix \texttt{\slshape type} and is used to
% apply the corresponding \pkg{expl3} commands.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_save:N #1
  { 
    \seq_set_split:Nxx \l_tmpa_seq 
       { \char_generate:nn { `_ } { 12 } } 
       { \cs_to_str:N #1 }
    \seq_pop_left:NN \l_tmpa_seq \l_tmpa_tl
%    \end{macrocode}
% The string |\l_tmpa_str| will contains the \emph{type} of the variable.
%    \begin{macrocode}
    \str_set:Nx \l_tmpa_str { \seq_item:Nn \l_tmpa_seq { -1 } }
    \use:c { \l_tmpa_str _if_exist:cF }
      { g _\seq_use:Nnnn \l_tmpa_seq _ _ _ }
      { 
        \use:c { \l_tmpa_str _new:c }
          { g _\seq_use:Nnnn \l_tmpa_seq _ _ _ } 
      }
    \use:c { \l_tmpa_str _gset_eq:cN } 
      { g _\seq_use:Nnnn \l_tmpa_seq _ _ _ } #1 
  }
%    \end{macrocode}
% 
% \medskip
% The command |\@@_restore:N| affects to the \pkg{expl3} variable the value of
% the (previously) set value of the corresponding \emph{global} variable.
%    \begin{macrocode}  
\cs_new_protected:Npn \@@_restore:N #1
  { 
    \seq_set_split:Nxx \l_tmpa_seq 
      { \char_generate:nn { `_ } { 12 } } 
      { \cs_to_str:N #1 }
    \seq_pop_left:NN \l_tmpa_seq \l_tmpa_tl
    \str_set:Nx \l_tmpa_str { \seq_item:Nn \l_tmpa_seq { -1 } }
    \use:c { \l_tmpa_str _set_eq:Nc } 
      #1 { g_\seq_use:Nnnn \l_tmpa_seq _ _ _ } 
  }
%    \end{macrocode}
% 
% 
% \bigskip
% We define a Tikz style |@@_node_style| for the |l|-nodes and |r|-nodes that
% will be created in the |\halign|. These nodes are Tikz nodes of shape
% ``rectangle'' but with zero width. An arrow between two nodes starts from the
% \emph{south} anchor of the first node and arrives at the \emph{north} anchor
% of the second node.
%    \begin{macrocode}
\tikzset
  { 
    @@_node_style / .style = 
      { 
        above = \l_@@_ystart_dim ,
        inner~sep = \c_zero_dim ,
        minimum~width = \c_zero_dim ,
        minimum~height = \l_@@_ygap_dim
      }
  }
%    \end{macrocode}
% If the user uses the option |show-nodes| (it's a \pkg{l3keys} option), the
% Tikz options |draw| and |red| will be appended to this style. This feature may
% be useful for debugging.\footnote{The |v|-nodes, created near the end of line
%   in |{DispWithArrows}| and |{DispWithArrows*}| are not shown with the option
%   |show-nodes|.}
%
% 
% \bigskip
% The style |@@_standard| is loaded in standard in the |{tikzpicture}| we need.
% The names of the nodes are prefixed by |wa| (by security) but also by a prefix
% which is the position-in-the-tree of the nested environments.
%    \begin{macrocode}
\tikzset
  { 
    @@_standard / .style = 
      { 
        remember~picture ,
        overlay ,
        name~prefix = wa - \l_@@_prefix_str -
      }
  }
%    \end{macrocode}
% 
% \bigskip
% We also define a style for the tips of arrow. The final user of the extension
% \pkg{witharrows} will use this style if he wants to draw an arrow directly
% with a Tikz command in his document (probably using the Tikz nodes created by
% |{WithArrows}| in the |\halign|).
%    \begin{macrocode}
\tikzset
  { 
    WithArrows / arrow / tips / .style = 
      { > = { Straight~Barb [ scale = 1.2 , bend ] } } 
  }
%    \end{macrocode}
%
% \bigskip
% The style |WithArrows/arrow| will be used to draw the arrows (more precisely,
% it will be passed to |every~path|).
%    \begin{macrocode}
\tikzset 
 { 
   WithArrows / arrow / .style  = 
     { 
       align = left ,
%    \end{macrocode}
%
% We have put the option |align = left| because we want to give the user the
% possibility of using |\\| in the labels.
%    \begin{macrocode}
       auto = left ,
%<*LaTeX>
       font = \small \itshape ,
%</LaTeX>
       WithArrows / arrow / tips ,
       bend~left = 45 ,
       -> 
     } 
 }
%    \end{macrocode}
%
% \bigskip
% The option |subequations| is an option which uses the environment
% |{subequations}| of \pkg{amsmath}. That's why, if \pkg{amsmath} is loaded, we
% add the key |subequations| to the list of the keys available in
% |\WithArrowsOptions| and |{DispWithArrows}|.
%    \begin{macrocode}
%<*LaTeX>
\AtBeginDocument 
  {
    \bool_if:NTF \c_@@_amsmath_loaded_bool
      {
        \seq_put_right:Nn \l_@@_options_WithArrowsOptions_seq { subequations }
        \seq_put_right:Nn \l_@@_options_DispWithArrows_seq { subequations }
      }
%    \end{macrocode}
%
% \bigskip
% In order to increase the interline in the environments |{WithArrows}|,
% |{DispWithArrows}|, etc., we will use the command |\spread@equation| of
% \pkg{amsmath}. When used, this command becomes no-op (in the current TeX
% group). Therefore, it will be possible to use the environments of
% \pkg{amsmath} (e.g. |{aligned}|) in an environment |{WithArrows}|.
% 
% Nevertheless, we want the extension \pkg{witharrows} available without
% \pkg{amsmath}. That's why we give a definition of |\spread@equation| if
% \pkg{amsmath} is not loaded (we put the code in a |\AtBeginDocument| because
% the flag |\c_@@_amsmath_loaded_bool| is itself set in a |\AtBeginDocument|).
%    \begin{macrocode}
      { 
%</LaTeX>
        \cs_new_protected:Npn \spread@equation
          { 
            \openup \jot   
            \cs_set_eq:NN \spread@equation \prg_do_nothing:
          }
%<*LaTeX>
      } 
  }
%</LaTeX>
%    \end{macrocode}
%
% \bigskip
%    \begin{macrocode}
\tl_new:N \l_@@_left_brace_tl
\tl_set_eq:NN \l_@@_left_brace_tl \c_novalue_tl
%    \end{macrocode}
%
% \bigskip
% \subsection{Variables}
%
% The boolean |\l_@@_in_WithArrows_bool| will be raised in an environment
% |{WithArrows}| and the boolean |\l_@@_in_dispwitharrows_bool| will be raised
% in an environment |{DispWithArrows}| or |{DispWithArrows*}|. The boolean
% |\l_@@_in_code_after_bool| will be raised during the execution of the
% |code-after| (option |code-after|).
%    \begin{macrocode}
\bool_new:N \l_@@_in_WithArrows_bool
\bool_new:N \l_@@_in_DispWithArrows_bool
\bool_new:N \l_@@_in_code_after_bool
%    \end{macrocode}
%
% \bigskip
% The following sequence is the position of the last environment |{WithArrows}|
% in the tree of the nested environments |{WithArrows}|.
%    \begin{macrocode}
\seq_new:N \g_@@_position_in_the_tree_seq
\seq_gput_right:Nn \g_@@_position_in_the_tree_seq 1
%    \end{macrocode}
%
% \bigskip
% The following counter will give the number of the last environment
% |{WithArrows}| of level~$0$. This counter will be used only in the definition
% of |\WithArrowsLastEnv|.
%    \begin{macrocode}
\int_new:N \g_@@_last_env_int
%    \end{macrocode}
%
% \bigskip
% The following integer indicates the position of the box that will be created
% for an environment |{WithArrows}| (not an environment |{DispWithArrows}|) :
% 0 (=|t|=|\vtop|), 1~(=|c|=|\vcenter|) or 2 (=|b|=|\vbox|).
%    \begin{macrocode}
\int_new:N \l_@@_pos_env_int 
%    \end{macrocode}
%
% \bigskip
% The integer |\l_@@_pos_arrow_int| indicates the position of the arrow with the
% following code (the option |v| is accessible only for the arrows in
% |code-after| where the options |i|, |group| et |groups| are not available).
%
% \begin{center}
% \begin{tabular}{l}
% \begin{tabular}{@{}l*8c@{}}
% \toprule
% option                 & |lr| & |ll| & |rl| & |rr| & |v| & |i| & |groups| & |group| \\
% \midrule
% |\l_@@_pos_arrow_int| & $0$  & $1$  & $2$  & $3$  & $4$ & $5$  & $6$  & $7$  \\
% \bottomrule
% \end{tabular} \\
% \footnotesize The option |v| can be used only in |\Arrow| in |code-after| (see
% below). 
% \end{tabular}
% \end{center}
%
%    \begin{macrocode}
\int_new:N \l_@@_pos_arrow_int
\int_set:Nn \l_@@_pos_arrow_int 3
%    \end{macrocode}
%
%
% \bigskip
% In the |\halign| of an environment |{WithArrows}| or |{DispWithArrows}|, we
% will have to use four counters:
% \begin{itemize}[beginpenalty=10000]
% \item |\g_@@_arrow_int| to count the arrows created in the environment ;
% \item |\g_@@_line_int| to count the lines of the |\halign| ;
% \item |\g_@@_col_int| to count the columns of the |\halign|.
% \end{itemize}
%
%
% These counters will be incremented in a cell of the |\halign| and, therefore,
% the incrementation must be global. However, we want to be able to include a
% |{WithArrows}| in another |{WithArrows}|. To do so, we must restore the
% previous value of these counters at the end of an environment |{WithArrows}|
% and we decide to manage a stack for each of these counters.
%    \begin{macrocode}
\seq_new:N \g_@@_arrow_int_seq
\int_new:N \g_@@_arrow_int
\seq_new:N \g_@@_line_int_seq
\int_new:N \g_@@_line_int
\seq_new:N \g_@@_col_int_seq
\int_new:N \g_@@_col_int
%    \end{macrocode}
% 
% We will also use a ``static'' version of the counter of columns, called
% |\g_@@_static_col_int|. The value will be set directly in each cell of the
% array by an instruction in the template of the |\halign|. The aim of this
% programmation is to try to detect some utilisation of |\omit| (which should be
% forbidden) in the cells of the |\halign|.
%    \begin{macrocode}
\seq_new:N \g_@@_static_col_int_seq
\int_new:N \g_@@_static_col_int
%    \end{macrocode}
%
% 
% \bigskip
% For the environment |{DispWithArrows}|, the comma list |\l_@@_tags_clist| will
% be the list of the numbers of lines to be tagged (with the counter |equation|
% of LaTeX). In fact, |\l_@@_tags_clist| may contain non negative integers but
% also three special values: |first|, |last| and |all|.
%    \begin{macrocode}
%<*LaTeX>
\clist_new:N \l_@@_tags_clist
\clist_set:Nn \l_@@_tags_clist { all }
%    \end{macrocode}
%
% \bigskip
% During the execution of an environment |{DispWithArrows}|, if a row must be
% tagged, the (local) value of |\l_@@_tags_clist| will be put (by convention) to
% |all|. 
%    \begin{macrocode}
\cs_new_protected:Npn \@@_test_if_to_tag:
  { 
    \clist_if_in:NVT \l_@@_tags_clist \g_@@_line_int
      { \clist_set:Nn \l_@@_tags_clist { all } }
  }
%</LaTeX>
%    \end{macrocode}
%
%
% \bigskip
% If the user has given a value for the option |command-name| (at the global or
% at the \emph{environment} level), a command with this name is defined locally
% in the environment with meaning |\@@_Arrow|. The initial value of the option
% |command-name| is ``|Arrow|'' and thus, by default, the name of the command
% will be |\Arrow|.
%    \begin{macrocode}
\str_new:N \l_@@_command_name_str
\str_set:Nn \l_@@_command_name_str { Arrow }
%    \end{macrocode}
%
% \bigskip
% The string |\l_@@_string_Arrow_for_msg_str| is only a string that will be
% displayed in some error messages. For example, if |command-name| is defined to
% be |Explanation|, this string will contain ``|\Arrow alias \Explanation|''. 
%    \begin{macrocode}
\str_new:N \l_@@_string_Arrow_for_msg_str 
\str_set:Nx \l_@@_string_Arrow_for_msg_str { \token_to_str:N \Arrow }
%    \end{macrocode}
%
% \bigskip
% The sequence |\g_@@_names_seq| will be the list of all the names of
% environments used (via the option |name|) in the document: two environments
% must not have the same name. However, it's possible to use the option
% |allow-duplicate-names|.
%    \begin{macrocode}
\seq_new:N \g_@@_names_seq
%    \end{macrocode}
% 
% \bigskip
% The boolean |\l_@@_sbwi_bool| corresponds to the option
% |standard-behaviour-with-items|. Since the version 1.16 of \pkg{witharrows},
% no vertical space is added between an |\item| of a LaTeX list and an
% environment |{DispWithArrows}|. With the option
% |standard-behaviour-with-items|, it's possible to restore the previous
% behaviour (which corresponds to the standard behaviour of |{align}| of
% \pkg{amsmath}). |\l_@@_sbwi_bool| is the boolean corresponding to this option.
%    \begin{macrocode}
%<*LaTeX>
\bool_new:N \l_@@_sbwi_bool 
%</LaTeX>
%    \end{macrocode}
% 
% \bigskip
%    \begin{macrocode}
%<*LaTeX>
\bool_new:N \l_@@_tag_star_bool
\bool_new:N \l_@@_tag_next_line_bool
\bool_new:N \l_@@_qedhere_bool
%</LaTeX>
\bool_new:N \l_@@_in_first_columns_bool
\bool_new:N \l_@@_new_group_bool
\bool_new:N \l_@@_initial_r_bool
\bool_new:N \l_@@_final_r_bool
\tl_new:N \l_@@_initial_tl
\tl_new:N \l_@@_final_tl
\int_new:N \l_@@_nb_cols_int
%    \end{macrocode}
% 
% \bigskip
% The string |\l_@@_format_str| will contain the \emph{format} of the array
% which is a succession of letters |r|, |c| and |l| specifying the type of the
% columns of the |\halign| (except the column for the labels of the equations
% in the environment |{DispWithArrows}|). 
%    \begin{macrocode}
\str_new:N \l_@@_format_str
%    \end{macrocode}
% 
% \bigskip
% The option |\l_@@_subequations_bool| corresponds to the option |subequations|.
%    \begin{macrocode}
%<*LaTeX>
\bool_new:N \l_@@_subequations_bool
%</LaTeX>
%    \end{macrocode}
% 
% \bigskip
% \subsection{The definition of the options}
%
% There are four levels where options can be set:
% \begin{itemize}[beginpenalty=10000]
% \item with |\usepackage[...]{witharrows}|: this level will be called
% \emph{package} level;
% \item with |\WithArrowsOptions{...}|: this level will be called \emph{global}
% level\footnote{This level is called \emph{global level} but the settings done
% by |\WithArrowsOptions| are local in the TeX sense: their scope corresponds to
% the current TeX group.};
% \item with |\begin{WithArrows}[...]|: this level will be called
% \emph{environment} level;
% \item with |\Arrow[...]| (included in |code-after|): this level will be called
% \emph{local} level.
% \end{itemize}
%
%
% \bigskip
% When we scan a list of options, we want to be able to raise an error if two
% options of position (|ll|, |rl|, |i|, etc.) of the arrows are present. That's
% why we keep the first option of position in a variable called
% |\l_@@_previous_key_str|. The following function |\@@_eval_if_allowed:n| will
% execute its argument only if a first key of position has not been set (and
% raise an error elsewhere). 
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_eval_if_allowed:n #1
  { 
    \str_if_empty:NTF \l_@@_previous_key_str
      { 
        \str_set_eq:NN \l_@@_previous_key_str \l_keys_key_tl
        #1
      }
      { \@@_error:n { Incompatible~options } }
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_fix_pos_option:n #1
  { \@@_eval_if_allowed:n { \int_set:Nn \l_@@_pos_arrow_int { #1 } } }
%    \end{macrocode}
%
% \bigskip
% First a set of keys that will be used at the global or environment level of
% options.
%    \begin{macrocode}
\keys_define:nn { WithArrows / Global }
  {
    max-length-of-arrow .dim_set:N = \l_@@_max_length_of_arrow_dim ,
    max-length-of-arrow .value_required:n = true ,
    max-length-of-arrow .initial:n = 2 cm ,
    ygap .dim_set:N = \l_@@_ygap_dim ,
    ygap .value_required:n = true ,
    ygap .initial:n = 0.4 ex ,
    ystart .dim_set:N = \l_@@_ystart_dim ,
    ystart .value_required:n = true ,
    ystart .initial:n = 0.4 ex ,
    more-columns .code:n = 
      \@@_msg_redirect_name:nn { Too~much~columns~in~WithArrows } { none } ,
    more-columns .value_forbidden:n = true,
    command-name .code:n =
      \str_set:Nn \l_@@_command_name_str { #1 }
      \str_set:Nx \l_@@_string_Arrow_for_msg_str
        { \c_backslash_str Arrow~alias~\c_backslash_str #1 } ,
    command-name .value_required:n = true ,
    tikz-code .tl_set:N = \l_@@_tikz_code_tl,
    tikz-code .initial:n = \draw~(#1)~to~node{#3}~(#2)~; ,
    tikz-code .value_required:n = true ,
    TikzCode .meta:n = { tikz-code = #1 } ,
    displaystyle .bool_set:N = \l_@@_displaystyle_bool ,
    displaystyle .default:n = true ,
    show-nodes .code:n =  
      \tikzset { @@_node_style / .append~style = { draw , red } } ,
    show-nodes .value_forbidden:n = true,
    show-node-names .bool_set:N = \l_@@_show_node_names_bool ,
    show-node-names .default:n = true ,
    group .code:n = 
      \str_if_empty:NTF \l_@@_previous_key_str
        {
          \str_set:Nn \l_@@_previous_key_str { group }
          \seq_remove_all:Nn \l_@@_options_Arrow_seq { xoffset }
          \int_set:Nn \l_@@_pos_arrow_int 7 
        }
        { \@@_error:n { Incompatible~options } } ,
    group .value_forbidden:n = true ,
    groups .code:n = 
      \str_if_empty:NTF \l_@@_previous_key_str
        { 
          \str_set:Nn \l_@@_previous_key_str { groups }
          \seq_if_in:NnF \l_@@_options_Arrow_seq { new-group }
            { \seq_put_right:Nn \l_@@_options_Arrow_seq { new-group } }
          \seq_remove_all:Nn \l_@@_options_Arrow_seq { xoffset }
          \int_set:Nn \l_@@_pos_arrow_int 6
        }
        { \@@_error:n { Incompatible~options } } ,
    groups .value_forbidden:n = true ,
    tikz   .code:n = \tikzset { WithArrows / arrow / .append~style = { #1 } } , 
    tikz   .initial:n         = \c_empty_tl ,
    tikz   .value_required:n  = true ,
    rr     .value_forbidden:n = true ,
    rr     .code:n            = \@@_fix_pos_option:n 3 ,
    ll     .value_forbidden:n = true ,
    ll     .code:n            = \@@_fix_pos_option:n 1 ,
    rl     .value_forbidden:n = true ,
    rl     .code:n            = \@@_fix_pos_option:n 2 ,
    lr     .value_forbidden:n = true ,
    lr     .code:n            = \@@_fix_pos_option:n 0 ,
    i      .value_forbidden:n = true ,
    i      .code:n            = \@@_fix_pos_option:n 5 ,
    xoffset .dim_set:N  = \l_@@_xoffset_dim ,
    xoffset .value_required:n  = true ,
    xoffset .initial:n = 3 mm ,
    jot .dim_set:N = \jot ,
    jot .value_required:n = true ,
    interline .skip_set:N = \l_@@_interline_skip ,
    interline .value_required:n = true ,
    start-adjust .dim_set:N = \l_@@_start_adjust_dim ,
    start-adjust .value_required:n = true ,
    start-adjust .initial:n = 0.4 ex ,
    end-adjust .dim_set:N = \l_@@_end_adjust_dim ,
    end-adjust .value_required:n = true ,
    end-adjust .initial:n = 0.4 ex ,
    adjust .meta:n  = { start-adjust = #1 , end-adjust = #1 } ,
    adjust .value_required:n = true ,
%    \end{macrocode}
%
% \medskip
% With the option |no-arrows|, the arrows won't be drawn. However, the ``first
% pass'' of the arrows is done and some errors may be detected. The
% nullification of |\@@_draw_arrows:nn| is for the standard arrows and the
% nullification of |\@@_draw_arrow:nnn| is for ``Arrow in |code-after|''.
%    \begin{macrocode}
    no-arrows .code:n = 
      \cs_set_eq:NN \@@_draw_arrows:nn \use_none:nn
      \cs_set_eq:NN \@@_draw_arrow:nnn \use_none:nnn  ,
    no-arrows .value_forbidden:n = true ,
  }
%    \end{macrocode}
% 
% \bigskip
% Now a set of keys specific to the environments |{WithArrows}| (and not
% |{DispWithArrow}}|). Despite its name, this set of keys will also be used in
% |\WithArrowsOptions|. 
%    \begin{macrocode}
\keys_define:nn { WithArrows / WithArrowsSpecific }
  { 
    t   .code:n            = \int_set:Nn \l_@@_pos_env_int O ,
    t   .value_forbidden:n = true ,
    c   .code:n            = \int_set:Nn \l_@@_pos_env_int 1 ,
    c   .value_forbidden:n = true ,
    b   .code:n            = \int_set:Nn \l_@@_pos_env_int 2 ,
    b   .value_forbidden:n = true
  }
%    \end{macrocode}
%
% \bigskip
% The following list of the (left) extensible delimiters of LaTeX is only for
% the validation of the key |replace-left-brace-by|.
%    \begin{macrocode}
\clist_new:N \c_@@_extensible_delimiters_clist
\clist_set:Nn \c_@@_extensible_delimiters_clist
  { 
    ., \{, (, [, \lbrace, \lbrack, \lgroup, \langle, \lmoustache, \lceil, \lfloor
  }
%<*LaTeX>
\AtBeginDocument
  { 
    \bool_if:nT 
      { \c_@@_amsmath_loaded_bool || \use:c { c_@@_unicode-math_loaded_bool } } 
      { 
        \clist_put_right:Nn \c_@@_extensible_delimiters_clist { \lvert, \lVert }
      }  
  }
%</LaTeX>
%    \end{macrocode}
%
%
% \bigskip
% Now a set of keys specific to the environments |{DispWithArrows}| and
% |{DispWithArrows*}| (and not |{WithArrows}|). Despite its name, this set of
% keys will also be used in |\WithArrowsOptions|. 
%    \begin{macrocode}
\keys_define:nn { WithArrows / DispWithArrowsSpecific }
  {  
    fleqn .bool_set:N = \l_@@_fleqn_bool ,
    fleqn .default:n = true ,
    mathindent .dim_set:N = \l_@@_mathindent_dim ,
    mathindent .value_required:n = true ,
    mathindent .initial:n = 25 pt ,
%<*LaTeX>
    notag .code:n = 
      \str_if_eq:nnTF { #1 } { true }
        { \clist_clear:N \l_@@_tags_clist }
        { \clist_set:Nn \l_@@_tags_clist { all } } ,
    notag .default:n = true ,
%    \end{macrocode}
% Since the option |subequations| is an option which insert the environment
% |{DispWithArrows}| in an environment |{subequations}| of \pkg{amsmath}, we
% must test whether the package \pkg{amsmath} is loaded. 
%    \begin{macrocode}
    subequations .code:n = 
      \bool_if:NTF \c_@@_amsmath_loaded_bool
        { \bool_set_true:N \l_@@_subequations_bool }
        { 
          \@@_error:n { amsmath~not~loaded } 
          \group_begin:
          \globaldefs = 1
          \@@_msg_redirect_name:nn { amsmath~not~loaded } { info }
          \group_end:
        } ,
    subequations .default:n = true ,
    subequations .value_forbidden:n = true ,
    nonumber .meta:n = notag ,
    allow-multiple-labels .code:n = 
      \@@_msg_redirect_name:nn { Multiple~labels } { none } ,
    allow-multiple-labels .value_forbidden:n = true ,
    tagged-lines .code:n =   
      \clist_set:Nn \l_@@_tags_clist { #1 }
      \clist_if_in:NnT \l_@@_tags_clist { first }
        {
          \clist_remove_all:Nn \l_@@_tags_clist { first }
          \clist_put_left:Nn \l_@@_tags_clist \c_one_int
        } ,
    tagged-lines .value_required:n = true ,
%</LaTeX>
    wrap-lines .bool_set:N = \l_@@_wrap_lines_bool ,
    wrap-lines .default:n = true ,
    replace-left-brace-by .code:n = 
      {
        \tl_set:Nx \l_tmpa_tl { \tl_head:n { #1 } }
        \clist_if_in:NVTF 
          \c_@@_extensible_delimiters_clist
          \l_tmpa_tl
          { \tl_set:Nn \l_@@_replace_left_brace_by_tl { #1 } }
          { \@@_error:n { Bad~value~for~replace~brace~by } }
      } ,
    replace-left-brace-by .initial:n = \lbrace ,
%    \end{macrocode}
%
% Since the version 1.16 of \pkg{witharrows}, no vertical space is added between
% an |\item| of a LaTeX list and an environment |{DispWithArrows}|. With the
% option |standard-behaviour-with-items|, it's possible to restore the previous
% behaviour (which corresponds to the standard behaviour of |{align}| of
% \pkg{amsmath}).
%    \begin{macrocode}
%<*LaTeX>>
    standard-behaviour-with-items .bool_set:N = \l_@@_sbwi_bool ,
    standard-behaviour-with-items .default:n = true 
%</LaTeX>
  }
%    \end{macrocode}
%
%
% \bigskip
% Now a set of keys which will be used in all the environments (but not in
% |\WithArrowsOptions}|). 
%
%    \begin{macrocode}
\keys_define:nn { WithArrows / Env } 
  { 
    name .code:n = 
%    \end{macrocode}
% First, we convert the value in a |str| because the list of the names will be a
% list of |str|.
%    \begin{macrocode}
      \str_set:Nn \l_tmpa_str { #1 }
      \seq_if_in:NVTF \g_@@_names_seq \l_tmpa_str
        { \@@_error:n { Duplicate~name } }
        { \seq_gput_left:NV \g_@@_names_seq \l_tmpa_str }
      \str_set_eq:NN \l_@@_name_str \l_tmpa_str ,
    name .value_required:n = true ,
    code-before .code:n = \tl_put_right:Nn \l_@@_code_before_tl { #1 } ,
    code-before .value_required:n = true,
    CodeBefore .meta:n = { code-before = #1 } ,
    code-after .code:n = \tl_put_right:Nn \l_@@_code_after_tl { #1 } ,
    code-after .value_required:n = true ,
    CodeAfter  .meta:n = { code-after = #1 } ,
    format .code:n = 
      \tl_if_empty:nTF { #1 } 
        { \@@_error:n { Invalid~option~format } }
        {
          \regex_match:nnTF { \A[rcl]*\Z } { #1 }
            { \tl_set:Nn \l_@@_format_str { #1 } }
            { \@@_error:n { Invalid~option~format } }
        } ,
    format .value_required:n = true ,
  }
%    \end{macrocode}
%
% 
% \bigskip
% Now, we begin the construction of the major sets of keys, named
% ``|WithArrows / WithArrows|'', ``|WithArrows / DispWithArrows|'' and 
% ``|WithArrows / WithArrowsOptions|''. Each of these sets of keys will be
% completed after.
%    \begin{macrocode}
\keys_define:nn { WithArrows } 
  { 
    WithArrows .inherit:n = 
      { 
        WithArrows / Global , 
        WithArrows / WithArrowsSpecific , 
        WithArrows / Env
      } , 
    DispWithArrows .inherit:n = 
      { 
        WithArrows / DispWithArrowsSpecific , 
        WithArrows / Global ,
        WithArrows / Env ,
      } ,
    WithArrowsOptions .inherit:n = 
      { 
        WithArrows / Global , 
        WithArrows / WithArrowsSpecific , 
        WithArrows / DispWithArrowsSpecific 
      } 
  }
%    \end{macrocode}
% 
% 
% \bigskip
% A sequence of |str| for the options available in |{WithArrows}|. This sequence
% will be used in the error messages and can be modified dynamically.
%    \begin{macrocode}
\seq_new:N \l_@@_options_WithArrows_seq
\@@_set_seq_of_str_from_clist:Nn \l_@@_options_WithArrows_seq
  { 
    adjust, b, c, code-after, code-before, command-name,
    displaystyle, end-adjust, 
    format, group, groups, i,
    interline, jot, ll,
    lr, max-length-of-arrow, more-columns, name, 
    no-arrows, rl, rr, 
    show-node-names, show-nodes, start-adjust,
    t, tikz, tikz-code, 
    xoffset, ygap, ystart 
  } 
\@@_convert_to_str_seq:N \l_@@_options_WithArrows_seq
%    \end{macrocode}
%
% \medskip
%    \begin{macrocode}
\keys_define:nn { WithArrows / WithArrows } 
  { 
    unknown .code:n  = 
      \@@_sort_seq:N \l_@@_options_WithArrows_seq 
      \@@_error:n { Unknown~option~WithArrows } 
  }
%    \end{macrocode}
%
% \bigskip
%    \begin{macrocode}
\keys_define:nn { WithArrows / DispWithArrows } 
  { 
    left-brace .tl_set:N = \l_@@_left_brace_tl ,
    unknown .code:n  = 
      \@@_sort_seq:N \l_@@_options_DispWithArrows_seq
      \@@_error:n { Unknown~option~DispWithArrows } 
  }
%    \end{macrocode}
%
% \bigskip
% A sequence of the options available in |{DispWithArrows}|. This sequence will
% be used in the error messages and can be modified dynamically.
%    \begin{macrocode}
\seq_new:N \l_@@_options_DispWithArrows_seq
\@@_set_seq_of_str_from_clist:Nn \l_@@_options_DispWithArrows_seq
  { 
    code-after, code-before, command-name, tikz-code, adjust,
    displaystyle, end-adjust, fleqn, group, format, groups, i, interline, jot,
    left-brace, ll, lr, max-length-of-arrow, mathindent, name, no-arrows,
    replace-left-brace-by, rl, rr, show-node-names, show-nodes, start-adjust,
    tikz, wrap-lines, xoffset, ygap, ystart,
%<*LaTeX>>  
    allow-multiple-labels, tagged-lines, nonumber, notag
%</LaTeX>
  }
%    \end{macrocode}
% 
%
%    \begin{macrocode}
\keys_define:nn { WithArrows / WithArrowsOptions } 
  { 
    allow-duplicate-names .code:n = 
      \@@_msg_redirect_name:nn { Duplicate~name } { none } ,
    allow-duplicate-names .value_forbidden:n = true ,
    unknown .code:n  = 
      \@@_sort_seq:N \l_@@_options_WithArrowsOptions_seq
      \@@_error:n { Unknown~option~WithArrowsOptions } 
  }
%    \end{macrocode}
% 
%
% \bigskip
% A sequence of the options available in |\WithArrowsOptions|. This sequence
% will be used in the error messages and can be modified dynamically.
%    \begin{macrocode}
\seq_new:N \l_@@_options_WithArrowsOptions_seq
\@@_set_seq_of_str_from_clist:Nn \l_@@_options_WithArrowsOptions_seq
  { 
    allow-duplicate-names, b, c, command-name, more-columns, tikz-code, adjust,
    displaystyle, end-adjust, fleqn, group, groups, i, interline, jot, ll, lr,
    mathindent, max-length-of-arrow, no-arrows, rl, rr, show-node-names,
    show-nodes, start-adjust, t, tikz, wrap-lines, xoffset, ygap, ystart, 
%<*LaTeX>>
    allow-multiple-labels, nonumber, notag, standard-behaviour-with-items,
    tagged-lines
%</LaTeX>
  }
%    \end{macrocode}
% 
% \bigskip
% The command |\@@_set_independent:| is a command without argument that will be
% used to specify that the arrow will be ``independent'' (of the potential
% groups of the option |group| or |groups|). This information will be stored in
% the field ``status'' of the arrow. Another value of the field ``status'' is
% ``new-group''.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_set_independent:
  { 
    \str_if_empty:NTF \l_@@_previous_key_str
      {
        \str_set_eq:NN \l_@@_previous_key_str \l_keys_key_tl
        \str_set:Nn \l_@@_status_arrow_str { independent } 
        \str_if_eq:VnF \l_keys_value_tl { NoValue }
          { \@@_error:n { Value~for~a~key } }
      }
      { \@@_error:n { Incompatible~options~in~Arrow } }
  }
%    \end{macrocode}
%
% \bigskip
% The options of an individual arrow are parsed twice. The first pass is when
% the command |\Arrow| is read. The second pass is when the arrows are drawn
% (after the end of the environment |{WithArrows}| or |{DispWithArrows}|). Now,
% we present the keys set for the first pass. The main goal is to extract
% informations which will be necessary during the scan of the arrows. For
% instance, we have to know if some arrows are ``independent'' or use the
% option ``new-group''.
%    \begin{macrocode}
\keys_define:nn { WithArrows / Arrow / FirstPass }
  { 
    jump .code:n = 
      \int_compare:nTF { #1 > 0 }
        { \int_set:Nn \l_@@_jump_int { #1 } }
        { \@@_error:n { Negative~jump } } ,
    jump .value_required:n  = true,
    rr .code:n = \@@_set_independent: ,
    ll .code:n = \@@_set_independent: ,
    rl .code:n = \@@_set_independent: ,
    lr .code:n = \@@_set_independent: ,
    i  .code:n = \@@_set_independent: ,
    rr .default:n = NoValue ,
    ll .default:n = NoValue ,
    rl .default:n = NoValue ,
    lr .default:n = NoValue ,
    i  .default:n = NoValue ,
    new-group .value_forbidden:n = true,
    new-group .code:n = 
      \int_compare:nTF { \l_@@_pos_arrow_int = 6 }
        { \str_set:Nn \l_@@_status_arrow_str { new-group } }
        { \@@_error:n { new-group~without~groups } } , 
%    \end{macrocode}
%
% \medskip
% The other keys don't give any information necessary during the scan of the
% arrows. However, you try to detect errors and that's why all the keys are
% listed in this keys set. An unknown key will be detected at the point of the
% command |\Arrow| and not at the end of the environment.
%    \begin{macrocode}
    tikz-code .code:n = \prg_do_nothing: ,
    tikz-code .value_required:n = true ,
    tikz .code:n = \prg_do_nothing: ,
    tikz .value_required:n = true ,
    start-adjust .code:n = \prg_do_nothing: ,
    start-adjust .value_required:n = true ,
    end-adjust .code:n = \prg_do_nothing: ,
    end-adjust .value_required:n = true ,
    adjust .code:n  = \prg_do_nothing: ,
    adjust .value_required:n = true ,
    xoffset .code:n = , 
    unknown .code:n = 
      \@@_sort_seq:N \l_@@_options_Arrow_seq
      \seq_if_in:NVTF \l_@@_options_WithArrows_seq \l_keys_key_tl
        { 
          \str_set:Nn \l_tmpa_str
           { ~However,~this~key~can~be~used~in~the~options~of~{WithArrows}. }  
        }
        { \str_clear:N \l_tmpa_str }
      \@@_error:n { Unknown~option~in~Arrow }
  }
%    \end{macrocode}
%
%
% \bigskip
% A sequence of the options available in |\Arrow|. This sequence will be used in
% the error messages and can be modified dynamically.
%    \begin{macrocode}
\seq_new:N \l_@@_options_Arrow_seq
\@@_set_seq_of_str_from_clist:Nn \l_@@_options_Arrow_seq
  { 
    adjust, end-adjust, i, jump, ll, lr, rl, rr, start-adjust, tikz, tikz-code,
    xoffset 
  }
%    \end{macrocode}
%
% \bigskip
%    \begin{macrocode}
\cs_new_protected:Npn \@@_fix_pos_arrow:n #1
  { 
    \str_if_empty:NT \l_@@_previous_key_str
      { 
        \str_set_eq:NN \l_@@_previous_key_str \l_keys_key_tl
        \int_set:Nn \l_@@_pos_arrow_int { #1 } 
      }
  }
%    \end{macrocode}
%
% \bigskip
% The options of the individual commands |\Arrows| are scanned twice. The second
% pass is just before the drawing of the arrow. In this set of keys, we don't
% put an item for the unknown keys because an unknown key would have been
% already detected during the first pass.
%
%    \begin{macrocode} 
\keys_define:nn {WithArrows / Arrow / SecondPass }
  { 
    tikz-code .tl_set:N = \l_@@_tikz_code_tl ,
    tikz-code .initial:n = \draw~(#1)~to~node{#3}~(#2)~; ,
    tikz .code:n = \tikzset { WithArrows / arrow / .append~style = { #1 } } ,
    tikz .initial:n = \c_empty_tl ,
    rr .code:n = \@@_fix_pos_arrow:n 3 ,
    ll .code:n = \@@_fix_pos_arrow:n 1 ,
    rl .code:n = \@@_fix_pos_arrow:n 2 ,
    lr .code:n = \@@_fix_pos_arrow:n 0 ,
    i  .code:n = \@@_fix_pos_arrow:n 5 ,
%    \end{macrocode}
%
% \medskip 
% The option |xoffset| is not allowed when the option |group| or the option
% |groups| is used except, if the arrow is independent or if there is only one
% arrow.
%    \begin{macrocode}
    xoffset .code:n  = 
      \bool_if:nTF 
        { 
          \int_compare_p:nNn \g_@@_arrow_int > 1 
          &&
          \int_compare_p:nNn \l_@@_pos_arrow_int > 5
          && 
          ! \str_if_eq_p:Vn \l_@@_status_arrow_str { independent }
        }
        { \@@_error:n { Option~xoffset~forbidden } }
        { \dim_set:Nn \l_@@_xoffset_dim { #1 } } ,
    xoffset .value_required:n = true ,
    start-adjust .dim_set:N = \l_@@_start_adjust_dim,
    end-adjust .dim_set:N = \l_@@_end_adjust_dim,
    adjust .code:n  =  
      \dim_set:Nn \l_@@_start_adjust_dim { #1 }
      \dim_set:Nn \l_@@_end_adjust_dim { #1 } ,
  }
%    \end{macrocode}
% 
% \bigskip
% |\WithArrowsOptions| is the command of the \pkg{witharrows} package to fix
% options at the document level. It's possible to fix in |\WithArrowsOptions|
% some options specific to |{WithArrows}| (in contrast with |{DispWithArrows}|)
% or specific to |{DispWithArrows}| (in contrast with |{WithArrows}|). That's
% why we have constructed a set of keys specific to |\WithArrowsOptions|.
%    \begin{macrocode}
%<*LaTeX>
\NewDocumentCommand \WithArrowsOptions { m }
%</LaTeX>
%<*plain-TeX>
\cs_set_protected:Npn \WithArrowsOptions #1
%</plain-TeX>
  { 
    \str_clear_new:N \l_@@_previous_key_str
    \keys_set:nn { WithArrows / WithArrowsOptions } { #1 } 
  }
%    \end{macrocode}
%
% 
% \bigskip
% \subsection{The command \textbackslash Arrow}
%
% In fact, the internal command is not named |\Arrow| but |\@@_Arrow|. Usually,
% at the beginning of an environment |{WithArrows}|, |\Arrow| is set to be
% equivalent to |\@@_Arrow|. However, the user can change the name with the
% option |command-name| and the user command for |\@@_Arrow| will be different.
% This mechanism can be useful when the user has already a command named
% |\Arrow| he still wants to use in the environments |{WithArrows}| or
% |{DispWithArrows}|. 
%
% \medskip
%    \begin{macrocode}
%<*LaTeX>
\NewDocumentCommand \@@_Arrow { O { } m ! O { } }
%</LaTeX>
%<*plain-TeX>
\cs_new_protected:Npn \@@_Arrow
  {
    \peek_meaning:NTF [ 
      { \@@_Arrow_i } 
      { \@@_Arrow_i [ ] }
  }
\cs_new_protected:Npn \@@_Arrow_i [ #1 ] #2 
  {
    \peek_meaning:NTF [
      { \@@_Arrow_ii [ #1 ] { #2 } }
      { \@@_Arrow_ii [ #1 ] { #2 } [ ] } 
  }
\cs_new_protected:Npn \@@_Arrow_ii [ #1 ] #2 [ #3 ]
%</plain-TeX>
  {
%    \end{macrocode}
%
% The counter |\g_@@_arrow_int| counts the arrows in the environment. The
% incrementation must be global (|gincr|) because the command |\Arrow| will be
% used in the cell of a |\halign|. It's recalled that we manage a stack for this
% counter.
%    \begin{macrocode}
    \int_gincr:N \g_@@_arrow_int
%    \end{macrocode}
% 
% \medskip
% We will construct a global property list to store the informations of the
% considered arrow. The six fields of this property list are ``initial'',
% ``final'', ``status'', ``options'', ``label'' and ``input-line''. In order to
% compute the value of ``final'' (the destination row of the arrow), we have to
% take into account a potential option |jump|. In order to compute the value of
% the field ``status'', we have to take into account options as |ll|, |rl|,
% |rr|, |lr|, etc. or |new-group|.
% 
% We will do that job with a first analyze of the options of the command
% |\Arrow| with a dedicated set of keys called |WithArrows/Arrow/FirstPass|.
% 
%    \begin{macrocode}
    \str_clear_new:N \l_@@_previous_key_str
    \keys_set:nn { WithArrows / Arrow / FirstPass } { #1 , #3 } 
%    \end{macrocode}
%
% \medskip
% We construct now a global property list to store the informations of the
% considered arrow with the six fields ``initial'', ``final'', ``status'',
% ``options'', ``label'' and ``input-line''.
%
% \smallskip
% \begin{enumerate}
% \item First, the row from which the arrow starts:
%    \begin{macrocode}
    \prop_put:NnV \l_tmpa_prop { initial } \g_@@_line_int
%    \end{macrocode}
%
% \item The row where the arrow ends (that's why it was necessary to analyze the
% key |jump|):
%    \begin{macrocode}
    \int_set:Nn \l_tmpa_int { \g_@@_line_int + \l_@@_jump_int }
    \prop_put:NnV \l_tmpa_prop { final } \l_tmpa_int
%    \end{macrocode}
%
% \item The ``status'' of the arrow, with 3 possible values: empty,
% |independent|, or |new-group|.
%    \begin{macrocode} 
    \prop_put:NnV \l_tmpa_prop { status } \l_@@_status_arrow_str
%    \end{macrocode}
% 
% \item The options of the arrow (it's a token list):
%    \begin{macrocode}
    \prop_put:Nnn \l_tmpa_prop { options } { #1 , #3 }
%    \end{macrocode}
%
% \item The label of the arrow (it's also a token list):
%    \begin{macrocode}
    \prop_put:Nnn \l_tmpa_prop { label } { #2 }
%    \end{macrocode}
% 
% \item The number of the line where the command |\Arrow| is issued in the TeX
% source (as of now, this is only useful for an error message).
%    \begin{macrocode}
    \prop_put:Nnx \l_tmpa_prop { input-line } \msg_line_number:
%    \end{macrocode}
% \end{enumerate}
%
% The property list has been created in a local variable for convenience. Now,
% it will be stored in a global variable indicating both the
% position-in-the-tree and the number of the arrow.
% 
%    \begin{macrocode}
    \prop_gclear_new:c 
      { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \g_@@_arrow_int _ prop }
    \prop_gset_eq:cN 
      { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \g_@@_arrow_int _ prop } 
      \l_tmpa_prop
  }       
%    \end{macrocode}
%
% \medskip
% The command |\Arrow| (or the corresponding command with a name given by the
% user with the option |command-name|) will be available only in the last column of
% the environments |{WithArrows}| and |{DispWithArrows}|. In the other columns,
% the command will be linked to the following command |\@@_Arrow_first_columns:|
% which will raise an error.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_Arrow_first_columns: 
  { \@@_error:n { Arrow~not~in~last~column } \@@_Arrow }
%    \end{macrocode}
%                                
%
% \bigskip
% \subsection{The environments \{WithArrows\} and \{DispWithArrows\}}
%
% \subsubsection{Code before the \textbackslash halign}
%
% The command |\@@_pre_halign:n| is a code common to the environments
% |{WithArrows}| and |{DispWithArrows}|. The argument is the list of options
% given to the environment.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_pre_halign:n #1
%    \end{macrocode}
%
% First, the initialization of |\l_@@_type_env_str| which is the name of the
% encompassing environment. In fact, this token list is used only in the error
% messages.
%    \begin{macrocode}
  { 
%<*LaTeX>
    \str_clear_new:N \l_@@_type_env_str
    \str_set:NV \l_@@_type_env_str \@currenvir
%</LaTeX>
%    \end{macrocode}
%
% \bigskip
% We deactivate the potential externalization of Tikz. The Tikz elements created
% by \pkg{witharrows} can't be externalized since they are created in Tikz
% pictures with |overlay| and |remember picture|.
%    \begin{macrocode}
    \cs_if_exist:NT \tikz@library@external@loaded
      { \tikzset { external / export = false } }
%    \end{macrocode}
%
% \bigskip
% The token list |\l_@@_name_str| will contain the potential name of the
% environment (given with the option |name|). This name will be used to create
% aliases for the names of the nodes.
%    \begin{macrocode}
    \str_clear_new:N \l_@@_name_str
%    \end{macrocode}
%
% \bigskip
% The parameter |\l_@@_status_arrow_str| will be used to store the ``status'' of
% an individual arrow. It will be used to fill the field ``status'' in the
% property list describing an arrow.
%    \begin{macrocode}
    \str_clear_new:N \l_@@_status_arrow_str
%    \end{macrocode}
%
% \bigskip
% The dimension |\l_@@_x_dim| will be used to compute the $x$-value for some
% vertical arrows when one of the options |i|, |group| and |groups| (values 5, 6
% and 7 of |\l_@@_pos_arrow_int|) is used.
%    \begin{macrocode}
    \dim_zero_new:N \l_@@_x_dim
%    \end{macrocode}
%
% \medskip
% The variable |\l_@@_input_line_str| will be used only to store, for each
% command |\Arrow| the line (in the TeX file) where the command is issued. This
% information will be stored in the field ``input-line'' of the arrow. As of
% now, this information is used only in the error message of an arrow impossible
% to draw (because it arrives after the last row of the environment).
%    \begin{macrocode}
    \str_clear_new:N \l_@@_input_line_str
%    \end{macrocode}
%
% 
% The initialization of the counters |\g_@@_arrow_int|, |\g_@@_line_int|,
% |\g_@@_col_int| and |\g_@@_static_col_int|. However, we have to save their
% previous values with the stacks created for this end. 
%    \begin{macrocode}
    \seq_gput_right:NV \g_@@_arrow_int_seq \g_@@_arrow_int
    \int_gzero:N \g_@@_arrow_int 
    \seq_gput_right:NV \g_@@_line_int_seq \g_@@_line_int
    \int_gzero:N \g_@@_line_int 
    \seq_gput_right:NV \g_@@_col_int_seq \g_@@_col_int
    \int_gzero:N \g_@@_col_int 
    \seq_gput_right:NV \g_@@_static_col_int_seq \g_@@_static_col_int
    \int_gzero:N \g_@@_static_col_int 
%    \end{macrocode}
%
% In the preamble of the |\halign|, there will be \emph{two} counters of the
% columns. The aim of this programmation is to detect the utilisation of a
% command |\omit| in a cell of the |\halign| (it should be forbidden).
% For example, in the part of the preamble concerning the third column (if there
% is a third column in the environment), we will have the following instructions :
% \begin{Verbatim}
%  \int_gincr:N \g_~@~@_col_int
%  \int_set:Nn \g_~@~@_static_col_int 3
% \end{Verbatim}
%  The counter |\g_@@_col_int| is incremented dynamically and the second is
%  static. If the user has used a command |\omit|, the dynamic incrementation is
%  not done in the cell and, at the end of the row, the difference between the
%  counters may infer the presence of |\omit| at least once.
% 
% \bigskip
% We also have to update the position on the nesting tree.
%    \begin{macrocode}
    \seq_gput_right:Nn \g_@@_position_in_the_tree_seq 1
%    \end{macrocode}
%
% The nesting tree is used to create a prefix which will be used in the names of
% the Tikz nodes and in the names of the arrows (each arrow is a property list
% of six fields). If we are in the second environment |{WithArrows}| nested in
% the third environment |{WithArrows}| of the document, the prefix will be |3-2|
% (although the position in the tree is $[3,2,1]$ since such a position always
% ends with a~$1$). First, we do a copy of the position-in-the-tree and then we
% pop the last element of this copy (in order to drop the last~$1$).
%    \begin{macrocode}
    \seq_set_eq:NN \l_tmpa_seq \g_@@_position_in_the_tree_seq
    \seq_pop_right:NN \l_tmpa_seq \l_tmpa_tl
    \str_clear_new:N \l_@@_prefix_str
    \str_set:Nx \l_@@_prefix_str { \seq_use:Nnnn \l_tmpa_seq - - - }
%    \end{macrocode}
% 
% \bigskip
% We define the command |\\| to be the command |\@@_cr:| (defined below). 
%    \begin{macrocode}
    \cs_set_eq:NN \\ \@@_cr:
    \dim_zero:N \mathsurround 
%    \end{macrocode}
%
% \bigskip
% These counters will be used later as variables.
%    \begin{macrocode}
    \int_zero_new:N \l_@@_initial_int
    \int_zero_new:N \l_@@_final_int
    \int_zero_new:N \l_@@_arrow_int
    \int_zero_new:N \l_@@_pos_of_arrow_int
    \int_zero_new:N \l_@@_jump_int
%    \end{macrocode}
%
% \medskip
% The counter |\l_@@_jump_int| corresponds to the option |jump|. Now, we set the
% initial value for this option.
%    \begin{macrocode}
    \int_set:Nn \l_@@_jump_int \c_one_int
%    \end{macrocode}
%
% \medskip
% The string |\l_@@_format_str| corresponds to the option |format|. Now, we set
% the initial value for this option.
%    \begin{macrocode}
    \str_set:Nn \l_@@_format_str { rl }
%    \end{macrocode}
% 
%
%
% \bigskip
% In (the last column of) |{DispWithArrows}|, it's possible to put several
% labels (for the same number of equation). That's why these labels will be
% stored in a sequence |\l_@@_labels_seq|.
%    \begin{macrocode}
%<*LaTeX>
    \seq_clear_new:N \l_@@_labels_seq
%    \end{macrocode}
%
%    \begin{macrocode}
    \bool_set_false:N \l_@@_tag_next_line_bool
%</LaTeX>
%    \end{macrocode}
% 
% \bigskip
% The value corresponding to the key |interline| is put to zero before the
% treatment of the options of the environment.\footnote{It's recalled that, by
% design, the option |interline| of an environment doesn't apply in the nested
% environments.}
%    \begin{macrocode}
    \skip_zero:N \l_@@_interline_skip
%    \end{macrocode}
%
% \bigskip
% The value corresponding to the key |code-before| is put to nil before the
% treatment of the options of the environment, because, of course, we don't want
% the code executed at the beginning of all the nested
% environments~|{WithArrows}|. Idem for |code-after|. 
%    \begin{macrocode}
    \tl_clear_new:N \l_@@_code_before_tl
    \tl_clear_new:N \l_@@_code_after_tl
%    \end{macrocode}
%
% \bigskip
% We process the options given to the environment |{WithArrows}| or
% |{DispWithArrows}|.
%    \begin{macrocode}
    \str_clear_new:N \l_@@_previous_key_str 
    \bool_if:NT \l_@@_in_WithArrows_bool
      { \keys_set:nn { WithArrows / WithArrows } { #1 } }
    \bool_if:NT \l_@@_in_DispWithArrows_bool
      { \keys_set:nn { WithArrows / DispWithArrows } { #1 } }
%    \end{macrocode}
%
% \medskip
% Now we link the command |\Arrow| (or the corresponding command with a name
% given by the user with the option |command-name|: that's why the following line
% must be after the loading of the options) to the command
% |\@@_Arrow_first_columns:| which will raise an error. 
%    \begin{macrocode}
    \cs_set_eq:cN \l_@@_command_name_str \@@_Arrow_first_columns: 
%    \end{macrocode}
% It's only in the last column of the environment that it will be linked to the
% command |\@@_Arrow:|.
%
% \medskip
% The counter |\l_@@_nb_cols_int| is the number of columns in the
% |\halign| (excepted the column for the labels of equations in
% |{DispWithArrows}| and excepted eventuals other columns in |{WithArrows}| allowed
% by the option |more-columns|).
%    \begin{macrocode}
    \int_set:Nn \l_@@_nb_cols_int { \str_count:N \l_@@_format_str } 
%    \end{macrocode}
%   
% \medskip
% Be careful! The following counter |\g_@@_col_int| will be used for two usages:
% \begin{itemize}[beginpenalty=10000]
% \item during, the construction of the preamble of the |\halign|, it will be
% used as counter for the number of the column under construction in the
% preamble (since the preamble is constructed backwards, |\g_@@_col_int| will go
% decreasing from |\l_@@_nb_cols_int| to $1$) ;
% \item once the preamble constructed, the primitive |\halign| is executed, and,
% in each row of the |\halign|, the counter |\g_@@_col_int| will be increased
% from column to column.
% \end{itemize}
%
%    \begin{macrocode}
    \int_gset_eq:NN \g_@@_col_int \l_@@_nb_cols_int
%    \end{macrocode}
% 
% \medskip
% We convert the format in a sequence because we use it as a stack (with the top
% of the stack at the end of the sequence) in the construction of the preamble.
%    \begin{macrocode}
    \seq_clear_new:N \l_@@_format_seq
    \seq_set_split:NnV \l_@@_format_seq { } \l_@@_format_str
%    \end{macrocode}
%
% \bigskip
% If the option |footnote| or the option |footnotehyper| is used, then we
% extract the footnotes with an environment |{savenotes}| (of the package
% \pkg{footnote} or the package \pkg{footnotehyper}).
%    \begin{macrocode}
%<*LaTeX>
    \bool_if:NT \g_@@_footnote_bool { \begin { savenotes } }
%</LaTeX>
%    \end{macrocode}
%
% \bigskip
% We execute the code |\l_@@_code_before_tl| of the option |code-before| of the
% environment after the eventual |\begin{savenotes}| and, symetrically, we will
% execute the |\l_@@_code_after_tl| before the eventual |\end{savenotes}| (we
% have a good reason for the last point: we want to extract the footnotes of the
% arrows executed in the |code-after|).
%    \begin{macrocode}
    \l_@@_code_before_tl
%    \end{macrocode}
%
% \bigskip
% The command |\spread@equation| is the command used by \pkg{amsmath} in the
% beginning of an alignment to fix the interline. When used, it becomes no-op.
% However, it's possible to use \pkg{witharrows} without \pkg{amsmath} since we
% have redefined |\spread@equation| (if it is not defined yet).
%    \begin{macrocode}
    \spread@equation
%    \end{macrocode}
%
%
%    \begin{macrocode}
%<*LaTeX>
    \cs_set_eq:NN \notag \@@_notag:
    \cs_set_eq:NN \nonumber \@@_nonumber:
    \cs_set_eq:NN \tag \@@_tag
    \cs_set_eq:NN \@@_old_label \label
    \cs_set_eq:NN \label \@@_label:n
    \cs_set_eq:NN \tagnextline \@@_tagnextline:
%</LaTeX>
  }
%    \end{macrocode}
% This is the end of |\@@_pre_halign:n|.
%
% \bigskip
% \subsubsection{The construction of the preamble of the \textbackslash halign}
%
% The control sequence |\@@_construct_halign:| will ``start'' the |\halign| and
% the preamble. In fact, it constructs all the preamble excepted the end of
% the last column (more precisely: except the part concerning the construction
% of the left node and the right node).
%
% The same function |\@@_construct_halign:| will be used both for the
% environment |{WithArrows}| and the environment |{DispWithArrows}|.
% 
% Several important points must be noted concerning that construction of the
% preamble.
% \begin{itemize}[beginpenalty=10000]
% \item The construction of the preamble is done by reading backwards the
% format |\l_@@_format_str| and adding the corresponding tokens in the input
% stream of TeX. That means that the part of the preamble concerning the last
% cell will be constructed first.
% \item The function |\@@_construct_halign:| is recursive in order to treat
% succesively all the letters of the preamble.
% \item Each part of the preamble is created with a |\use:x| function. This
% expansion of the preamble gives the ability of controlling which parts of the
% code will be expanded during the construction of the preamble (other parts
% will be expanded and executed only during the execution of the |\halign|).
% \item The counter |\g_@@_col_int| is used during the loop of the construction
% of the preamble but, it will also appears in the preamble (we could have
% chosen two differents counters but this way saves a counter).
% \end{itemize}
% 
%    \begin{macrocode}
\cs_new_protected:Npn \@@_construct_halign:
  {
    \seq_pop_right:NNTF \l_@@_format_seq \l_@@_type_col_str
      {
%    \end{macrocode}
% Here is the |\use:x| which is fundamental: it will really construct the part
% of the preamble corresponding to a column by expanding only some parts of the
% following code.
%    \begin{macrocode}
        \use:x
          {
%    \end{macrocode}
% Before the recursive call of |\@@_construct_halign:|, we decrease the integer
% |\g_@@_col_bool|. But, during the construction of the column which is
% constructed first (that is to say which is the last column of the |\halign|),
% it is \emph{not} lowered because |\int_decr:N|, which is protected, won't be
% expanded by the |\use:x|.
%
% We begin the construction of a generic column.
%    \begin{macrocode}
            \int_gdecr:N \g_@@_col_int
            \@@_construct_halign:
            \int_compare:nNnT \g_@@_col_int = \l_@@_nb_cols_int
              { 
%    \end{macrocode}
% We redefine the command |\Arrow| (or the name given to the corresponding
% command by the option |command-name|) in each cell of the last column.
% The braces around |\l_@@_command_name_str| are mandatory because
% |\l_@@_command_name_str| will be expanded by the |\use:x| and the command
% |\cs_set_eq:cN| must still be efficient during the execution of the |\halign|.
%    \begin{macrocode}
                \cs_set_eq:cN { \l_@@_command_name_str } \@@_Arrow
%<*LaTeX>
                \bool_if:NT \l_@@_in_DispWithArrows_bool
                  {
%    \end{macrocode}
% The command |\@@_test_if_to_tag:| (which is protected and, thus, will not be
% expanded during the construction of the preamble) will test, at each row,
% whether the current row must be tagged (and the tag will be put in the very
% last column).
%    \begin{macrocode}
                    \@@_test_if_to_tag:
%    \end{macrocode}
% The command |\@@_set_qedhere:| will do a redefinition of |\qedhere| in each
% cell of the last column.
%    \begin{macrocode}
                    \bool_if:NT \c_@@_amsthm_loaded_bool \@@_set_qedhere:
                  }
%</LaTeX>
              }
            \str_if_eq:VnT \l_@@_type_col_str { c } \hfil
            \str_if_eq:VnT \l_@@_type_col_str { r } \hfill
            \int_gincr:N \g_@@_col_int
            \int_gset:Nn \g_@@_static_col_int { \int_use:N \g_@@_col_int }
            \c_math_toggle_token
              {
                { }
                \bool_if:NT \l_@@_displaystyle_bool \displaystyle
                ####
              }
            \c_math_toggle_token
            \int_compare:nNnTF \g_@@_col_int = \l_@@_nb_cols_int
              { \@@_construct_nodes: }
              {
%    \end{macrocode}
% The following glue (|\hfil|) will be added only if we are not in the last cell
% because, in the last cell, a glue (=skip) is added between the nodes (in
% |\@@_construct_nodes:|). 
%    \begin{macrocode}
                \str_if_eq:VnT \l_@@_type_col_str { l } \hfil
                \str_if_eq:VnT \l_@@_type_col_str { c } \hfil
                \bool_if:NT \l_@@_in_DispWithArrows_bool { \tabskip = \c_zero_skip }
                &
              }
          } 
      }
%    \end{macrocode}
% Now the tokens that will be inserted after the analyze of all the tokens of
% the format: here is the token |\halign|.
%    \begin{macrocode}
      { 
        \bool_if:NTF \l_@@_in_WithArrows_bool
          {
            \ialign
            \bgroup
          }
          {
            \halign to \l_@@_linewidth_dim
            \bgroup
            \bool_if:NT \l_@@_fleqn_bool
              { \skip_horizontal:N \l_@@_mathindent_dim }
          }
        \int_gincr:N \g_@@_line_int 
        \int_gzero:N \g_@@_col_int
        \tl_if_eq:NNF \l_@@_left_brace_tl \c_novalue_tl
          {
            \skip_horizontal:n 
              { \box_wd:N \l_@@_left_brace_box + \l_@@_delim_wd_dim } 
          }
        \strut
      }
  }
%    \end{macrocode}
% 
%
% \bigskip
% The command |\@@_construct_nodes:| is only for the lisibility of the code
% because, in fact, it is used only once. It constructs the ``left node'' and
% the ``right node'' at the end of each row of the arrow.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_construct_nodes:
  { 
%    \end{macrocode}
% We create the ``left node'' of the line (when using macros in Tikz node names,
% the macros have to be fully expandable: here, |\int_use:N| is fully
% expandable).
%    \begin{macrocode}
    \tikz [ remember~picture , overlay ] 
      \node 
        [ 
          node~contents = { } ,
          @@_node_style ,
          name = wa - \l_@@_prefix_str - \int_use:N \g_@@_line_int - l ,
          alias = 
            { 
              \str_if_empty:NF \l_@@_name_str
                { \l_@@_name_str - \int_use:N \g_@@_line_int - l }
            } 
        ] 
        ;
    \hfil
%    \end{macrocode}
%
% \bigskip
% Now, after the |\hfil|, we create the ``right node'' and, if the option
% |show-node-names| is raised, the name of the node is written in the document
% (useful for debugging).
%    \begin{macrocode}
    \tikz [ remember~picture , overlay ] 
      \node 
        [ 
          node~contents = { } ,
          @@_node_style ,
          name = wa - \l_@@_prefix_str - \int_use:N \g_@@_line_int - r ,
          alias = 
            {
              \str_if_empty:NF \l_@@_name_str
                { \l_@@_name_str - \int_use:N \g_@@_line_int - r }
            } 
        ] 
        ;
    \bool_if:NT \l_@@_show_node_names_bool
      { 
        \hbox_overlap_right:n 
          { \small wa - \l_@@_prefix_str - \int_use:N \g_@@_line_int - r }
      }
  }
%    \end{macrocode}
%
%
%
% \bigskip
% \subsubsection{The environment \{WithArrows\}}
%
% 
%    \begin{macrocode}
%<*LaTeX>
\NewDocumentEnvironment { WithArrows } { ! O { } }
%</LaTeX>
%<*plain-TeX>
\cs_new_protected:Npn \WithArrows 
  {
    \group_begin:
    \peek_meaning:NTF [
     { \WithArrows_i }
     { \WithArrows_i [  ] }
  }
\cs_new_protected:Npn \WithArrows_i [ #1 ]
%</plain-TeX>
  { 
    \bool_set_true:N \l_@@_in_WithArrows_bool
    \bool_set_false:N \l_@@_in_DispWithArrows_bool
%<*plain-TeX>
    \str_clear_new:N \l_@@_type_env_str
    \str_set:Nn \l_@@_type_env_str { WithArrows }
%</plain-TeX>
    \@@_pre_halign:n { #1 } 
    \if_mode_math: \else:
      \@@_error:n { WithArrows~outside~math~mode }
    \fi:
%    \end{macrocode}
%
% \bigskip 
% The environment begins with a |\vtop|, a |\vcenter| or a
% |\vbox|\footnote{Notice that the use of |\vtop| seems color-safe here...}
% depending of the value of |\l_@@_pos_env_int| (fixed by the options |t|, |c|
% or |b|). The environment |{WithArrows}| must be used in math mode\footnote{An
% error is raised if the environment is used outside math mode.} and therefore,
% we can use |\vcenter|.
%    \begin{macrocode}
    \int_case:nn \l_@@_pos_env_int { 0 \vtop 1 \vcenter 2 \vbox }
    \bgroup
%    \end{macrocode}
%
% \bigskip
% We begin the |\halign| and the preamble. During the construction of the
% preamble, |\l_tmpa_int| will be incremented during each column constructed.
%    \begin{macrocode}
    \@@_construct_halign: 
%    \end{macrocode}
% 
% 
% \medskip
% In fact, the construction of the preamble is not finished. We add a little more.
% 
% \medskip
% An environmemnt |{WithArrows}| should have a number of columns equal to the
% length of its format (by default, 2 since the default format is |rl|).
% Nevertheless, if the user wants to use more columns (without arrows)
% it's possible with the option |more-columns|.
%    \begin{macrocode}
    && 
    \@@_error:n { Too~much~columns~in~WithArrows }
    \c_math_toggle_token
    \bool_if:NT \l_@@_displaystyle_bool \displaystyle 
    { ## } 
    \c_math_toggle_token
    \cr
  }
%    \end{macrocode}
%
%
% \bigskip 
% We begin the second part of the environment |{WithArrows}|. We have two
% |\egroup|\,: one for the |\halign| and one for the |\vtop| (or |\vcenter| or
% |\vbox|).
%    \begin{macrocode}
%<*plain-TeX>
\cs_new_protected:Npn \endWithArrows 
%</plain-TeX>
  {
    \\
    \egroup 
    \egroup
    \@@_post_halign:
%    \end{macrocode}
%
% \bigskip
% If the option |footnote| or the option |footnotehyper| is used, then we
% extract the footnotes with an environment |{footnote}| (of the package
% \pkg{footnote} or the package \pkg{footnotehyper}).
%    \begin{macrocode}
%<*LaTeX>
    \bool_if:NT \g_@@_footnote_bool { \end { savenotes } }
%</LaTeX>
%<*plain-TeX>
    \group_end:
%</plain-TeX>
  }
%    \end{macrocode}
% This is the end of the environment |{WithArrows}|.
% 
%
% \bigskip
% \subsubsection{After the construction of the \textbackslash halign}
%
% The command |\@@_post_halign:| is a code common to the second part of the
% environment |{WithArrows}| and the environment |{DispWithArrows}|.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_post_halign:
%    \end{macrocode}
%
% \bigskip
% The command |\WithArrowsRightX| is not used by \pkg{witharrows}. It's only a
% convenience given to the user.
%    \begin{macrocode}
  { 
    \cs_set:Npn \WithArrowsRightX { \g_@@_right_x_dim }  
%    \end{macrocode}
%
% \bigskip
% We use |\normalbaselines| of plain-TeX because we have used
% |\spread@equation| (of \pkg{amsmath} or defined directly if \pkg{amsmath} is
% not loaded) and you don't want |\spread@equation| to have effects in the
% labels of the arrows.
%    \begin{macrocode}
    \normalbaselines
%    \end{macrocode}
%
% \bigskip 
% If there is really arrows in the environment, we draw the arrows.
%    \begin{macrocode}
    \int_compare:nNnT \g_@@_arrow_int > 0
      { 
%    \end{macrocode}
% If there is only one arrow, the options |group| and |groups| do not really
% make sense and it will be quicker to act as if we were in option |i| (moreover,
% it allows the option |xoffset| for the unique arrow).
%    \begin{macrocode}
        \int_compare:nNnT \g_@@_arrow_int = 1 
          {
            \int_compare:nNnT \l_@@_pos_arrow_int > 5
              { \int_set:Nn \l_@@_pos_arrow_int 5 }
          }
        \@@_scan_arrows:
      }
%    \end{macrocode}
%
% \bigskip
% We will execute the code specified in the option |code-after|, after some
% settings. 
%    \begin{macrocode}
    \group_begin:
      \tikzset { every~picture / .style = @@_standard }
%    \end{macrocode}
% The command |\WithArrowsNbLines| is not used by \pkg{witharrows}. It's only a
% convenience given to the user.  
%    \begin{macrocode}
      \cs_set:Npn \WithArrowsNbLines { \int_use:N \g_@@_line_int }
%    \end{macrocode}
% The command |\MultiArrow| is available in |code-after|, and we have a special
% version of |\Arrow|, called ``|\Arrow| in |code-after|'' in the
% documentation.\footnote{As for now, |\MultiArrow| has no option, and that's
% why its internal name is a name of \pkg{expl3} with the signature |:nn|
% whereas |\Arrow| in |code-after| provides options and has the name of a
% function defined with |\NewDocumentCommand|.}
%    \begin{macrocode}
      \cs_set_eq:NN \MultiArrow \@@_MultiArrow:nn
      \cs_set_eq:cN \l_@@_command_name_str \@@_Arrow_code_after
      \bool_set_true:N \l_@@_in_code_after_bool
      \l_@@_code_after_tl
    \group_end:
%    \end{macrocode}
%
% \bigskip
% We update the position-in-the-tree. First, we drop the last component and then
% we increment the last element.
%    \begin{macrocode}
    \seq_gpop_right:NN \g_@@_position_in_the_tree_seq \l_tmpa_tl
    \seq_gpop_right:NN \g_@@_position_in_the_tree_seq \l_tmpa_tl
    \seq_gput_right:Nx \g_@@_position_in_the_tree_seq 
      { \int_eval:n { \l_tmpa_tl + 1 } }
%    \end{macrocode}
%
% \bigskip
% We update the value of the counter |\g_@@_last_env_int|. This counter is used
% only by the user function |\WithArrowsLastEnv|.
%    \begin{macrocode}
    \int_compare:nNnT { \seq_count:N \g_@@_position_in_the_tree_seq } = 1
      { \int_gincr:N \g_@@_last_env_int }
%    \end{macrocode}
%
% \bigskip
% Finally, we restore the previous values of the counters |\g_@@_arrow_int|,
% |\g_@@_col_int| and |\g_@@_static_col_int|. It is recalled that we manage four
% stacks in order to be able to do such a restoration.
%    \begin{macrocode}
    \seq_gpop_right:NN \g_@@_arrow_int_seq \l_tmpa_tl 
    \int_gset:Nn \g_@@_arrow_int \l_tmpa_tl 
    \seq_gpop_right:NN \g_@@_line_int_seq \l_tmpa_tl
    \int_gset:Nn \g_@@_line_int \l_tmpa_tl
    \seq_gpop_right:NN \g_@@_col_int_seq \l_tmpa_tl
    \int_gset:Nn \g_@@_col_int \l_tmpa_tl
    \seq_gpop_right:NN \g_@@_static_col_int_seq \l_tmpa_tl
    \int_gset:Nn \g_@@_static_col_int \l_tmpa_tl
  }
%    \end{macrocode}
% That's the end of the command |\@@_post_halign:|.
%
% \bigskip
% \subsubsection{The command of end of row}
%
% We give now the definition of |\@@_cr:| which is the definition of |\\| in an
% environment |{WithArrows}|. The two \pkg{expl3} commands
% |\group_align_safe_begin:| and |\group_align_safe_end:| are specifically
% designed for this purpose: test the token that follows in an |\halign|
% structure.
%
% First, we remove an eventual token |*| (just after the |\\|: there should not
% be space between the two) since the commands |\\| and |\\*| are equivalent in
% an environment |{WithArrows}| (an environment |{WithArrows}|, like an
% environment |{aligned}| of \pkg{amsmath}, is always unbreakable). 
%    \begin{macrocode}
\cs_new_protected:Npn \@@_cr:
  { 
    \scan_stop:
%    \end{macrocode}
% We try to detect some |\omit| (as of now, an |\omit| in the last column is
% not detected).
%    \begin{macrocode}
    \int_compare:nNnF \g_@@_col_int = \g_@@_static_col_int
      { \@@_error:n { omit~probably~used } }
    \prg_replicate:nn { \l_@@_nb_cols_int - \g_@@_static_col_int } { & { } } 
    \group_align_safe_begin:
    \peek_meaning_remove:NTF * \@@_cr_i: \@@_cr_i:
  }
%    \end{macrocode}
%
% \medskip
% Then, we peek the next token to see if it's a |[|. In this case, the command
% |\\| has an optional argument which is the vertical skip (=glue) to put.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_cr_i:
  { \peek_meaning:NTF [ \@@_cr_ii: { \@@_cr_ii: [ \c_zero_dim ] } }
%    \end{macrocode}
% 
% \bigskip
% Now, we test if the next token is the token |\end|. Indeed, we want to test if
% the following tokens are |\end{WithArrows}| (or |\end{DispWithArrows}|, etc).
% In this case, we raise an error because the user must not put "\\" at the end
% of its alignment.
%    \begin{macrocode}
%<*LaTeX>
\cs_new_protected:Npn \@@_cr_ii: [ #1 ]
  { 
    \peek_meaning_ignore_spaces:NTF \end 
      { 
        \@@_cr_iii:n { #1 } 
%    \end{macrocode}
% The analyse of the argument of the token |\end| must be after the
% |\group_align_safe_end:| which is the beginning of |\@@_cr_iii:n|.
%    \begin{macrocode}
        \@@_analyze_end:Nn 
      }
      { \@@_cr_iii:n { #1 } }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_cr_iii:n #1 
%</LaTeX>
%<*plain-TeX>
\cs_new_protected:Npn \@@_cr_ii: [ #1 ] 
%</plain-TeX>
  {
    \group_align_safe_end:
%    \end{macrocode}
% For the environment |{DispWithArrows}|, the behaviour of |\\| is different
% because we add the last column which is the column for the tag (number of the
% equation). Even if there is no tag, this column is used for the
% |v|-nodes.\footnote{The |v|-nodes are used to compute the abscissa of the
% right margin, used by the option |wrap-lines|.}
%    \begin{macrocode}
    \bool_if:NT \l_@@_in_DispWithArrows_bool
%    \end{macrocode}
% At this stage, we know that we have a tag to put if (and only if) the value of
% |\l_@@_tags_clist| is the comma list |all| (only one element). Maybe,
% previously, the value of |\l_@@_tags_clist| was, for example, |1,last| (which
% means that only the first line and the last line must be tagged). However, in
% this case, the comparison with the number of line has be done before and, now,
% if we are in a line to tag, the value of |\l_@@_tags_clist| is |all|.
%    \begin{macrocode}
      { 
%<*LaTeX>
        \clist_if_in:NnTF \l_@@_tags_clist { all }
          {
%    \end{macrocode}
% Here, we can't use |\refstepcounter{equation}| because if the user has issued
% a |\tag| command, we have to use |\l_@@_tag_tl| and not |\theequation|. That's
% why we have to do the job done by |\refstepcounter| manually.
% 
% First, the incrementation of the counter (potentially).
%    \begin{macrocode}
            \tl_if_empty:NT \l_@@_tag_tl { \int_gincr:N \c@equation }
%    \end{macrocode}
% 
% We store in |\g_tmpa_tl| the tag we will have to compose at the end of the
% line. We use a global variable because we will use it in the \emph{next} cell
% (after the |&|).
%    \begin{macrocode}
            \cs_gset:Npx \g_tmpa_tl
              { \tl_if_empty:NTF \l_@@_tag_tl \theequation \l_@@_tag_tl }
%    \end{macrocode}
% It's possible to put several labels for the same line (it's not possible in
% the environments of \pkg{amsmath}). That's why the differents labels of a same
% line are stored in a sequence |\l_@@_labels_seq|.
%    \begin{macrocode}
            \seq_if_empty:NF \l_@@_labels_seq
              {
%    \end{macrocode}
% Now, we do the job done by |\refstepcounter| and by the redefinitions of
% |\refstepcounter| done by some packages (the incrementation of the counter has
% been done yet).
%
% First an action which is in the definition of |\refstepcounter|. 
%    \begin{macrocode}
                \cs_set:Npx \@currentlabel { \p@equation \g_tmpa_tl }
%    \end{macrocode}
% Then, an action done by \pkg{hyperref} in its redefinition of
% |\refstepcounter|.
%    \begin{macrocode}
                \bool_if:NT \c_@@_hyperref_loaded_bool
                  { 
                    \str_set:Nn \This@name { equation }
                    \hyper@refstepcounter { equation }
                  }
%    \end{macrocode}
% Then, an action done by \pkg{cleveref} in its redefinition of
% |\refstepcounter|. The package \pkg{cleveref} creates in the |aux| file a
% command |\cref@currentlabel| similar to |\@currentlabel| but with more
% informations.
%    \begin{macrocode}        
                \bool_if:NT \c_@@_cleveref_loaded_bool
                  {
                    \cref@constructprefix { equation } \cref@result
                    \protected@edef \cref@currentlabel
                      { 
                        [ 
                          \cs_if_exist:NTF \cref@equation@alias 
                            \cref@equation@alias 
                            { equation } 
                        ] 
                        [ \arabic { equation } ] [ \cref@result ]
                        \p@equation \g_tmpa_tl
                      }
                  }
%    \end{macrocode}
% Now, we can issue the command |\label| (some packages may have redefined
% |\label|, for example \pkg{typedref}) for each item in the sequence of the
% labels (it's possible with \pkg{witharrows} to put several labels to the same
% line and that's why the labels are in the sequence |\l_@@_labels_seq|).
%    \begin{macrocode}
                \seq_map_function:NN \l_@@_labels_seq \@@_old_label
              }
%    \end{macrocode}
% We save the booleans |\l_@@_tag_star_bool| and |\l_@@_qedhere_bool| because
% they will be used in the \emph{next} cell (after the |&|). We recall that the
% cells of a |\halign| are TeX groups.
%    \begin{macrocode}
            \@@_save:N \l_@@_tag_star_bool
            \@@_save:N \l_@@_qedhere_bool
            \bool_if:NT \l_@@_tag_next_line_bool 
              { 
                \openup -\jot 
                \bool_set_false:N \l_@@_tag_next_line_bool 
                \notag \\ & 
              }
            & 
            \@@_restore:N \l_@@_tag_star_bool
            \@@_restore:N \l_@@_qedhere_bool
            \bool_if:NT \l_@@_qedhere_bool 
               { \hbox_overlap_left:n \@@_qedhere_i: }
            \cs_set_eq:NN \theequation \g_tmpa_tl
            \bool_if:NT \l_@@_tag_star_bool 
              { \cs_set_eq:NN \tagform@ \prg_do_nothing: }
%    \end{macrocode}
% We use |\@eqnnum| (we recall that there are two definitions of |\@eqnnum|, a
% standard definition and another, loaded if the class option |leqno| is used).
% However, of course, the position of the |v|-node is not the same whether the
% option |leqno| is used or not. That's here that we use the flag
% |\c_@@_leqno_bool|.
%    \begin{macrocode}
            \hbox_overlap_left:n 
              { 
                \bool_if:NF \c_@@_leqno_bool
                  { 
                    \tikz [ @@_standard ] 
                      \coordinate ( \int_use:N \g_@@_line_int - v ) ; 
                  }
                \quad
                \@eqnnum 
              }
            \bool_if:NT \c_@@_leqno_bool
              { 
                \tikz [ @@_standard ] 
                  \coordinate ( \int_use:N \g_@@_line_int - v ) ; 
              } 
          }
          { 
            \@@_save:N \l_@@_qedhere_bool 
%</LaTeX>
            & 
%<*LaTeX>
            \@@_restore:N \l_@@_qedhere_bool
            \bool_if:NT \l_@@_qedhere_bool 
               { \hbox_overlap_left:n \@@_qedhere_i: }
%</LaTeX>
            \tikz [ @@_standard ] 
               \coordinate ( \int_use:N \g_@@_line_int - v ) ; 
%<*LaTeX>
          }
%</LaTeX>
      }
    \dim_compare:nNnT { #1 } < \c_zero_dim
       { \@@_error:n { option~of~cr~negative } }

    \cr 
    \noalign 
      { 
        \dim_set:Nn \l_tmpa_dim { \dim_max:nn { #1 } \c_zero_dim }
        \skip_vertical:n { \l_tmpa_dim + \l_@@_interline_skip }
        \scan_stop: 
      }  
  }
%    \end{macrocode}
% According to the documentation of \pkg{expl3}, the previous addition in 
% ``|#1 + \l_@@_interline_skip|'' is really an addition of skips (=glues).
%
%
% The following command will be used when, after a |\\| (and its optional
% arguments) there is a |\end|. You want to known if this is the end of the
% environment |{WithArrows}| (or |{DispWithArrows}|, etc.) because, in this
% case, we will explain that the environment must not be ended by |\\|. If it is
% not the case, that means it's a classical situation of LaTeX environments not
% correctly imbricated and there will be a LaTeX error.
%    \begin{macrocode}
%<*LaTeX>
\cs_new_protected:Npn \@@_analyze_end:Nn #1 #2
  {
    \exp_args:NV \str_if_eq:nnT \l_@@_type_env_str { #2 }
      { 
        \@@_error:n { newline~at~the~end~of~env } 
        \group_begin:
        \globaldefs = 1
        \@@_msg_redirect_name:nn { newline~at~the~end~of~env } { none } 
        \group_end:
      }
%    \end{macrocode}
% We reput in the stream the |\end{...}| we have extracted.
%    \begin{macrocode}
    \end { #2 }
  }
%</LaTeX>
%    \end{macrocode}
%
% \bigskip
% \subsubsection{The environment \{DispWithArrows\}}
%
% For the environment |{DispWithArrows}|, the general form of the construction
% is of the type:
%
% |\[\vtop{\halign to \displaywidth {...}}\]|
% 
% The purpose of the |\vtop| is to have an environment unbreakable.
%
% However, if we are juste after an item of a LaTeX list or at the beginning of
% a |{minipage}|, the construction is slightly different:
%
% |\[\vtop{\halign to \linewidth {...}}\]|
% 
% 
% \bigskip
% The boolean |\l_@@_in_label_or_minipage_bool| will be raised if we are just after a |\item|
% of a list of LaTeX or at the beginning of a |{minipage}|.
%    \begin{macrocode}
%<*LaTeX>
\bool_new:N \l_@@_in_label_or_minipage_bool
%</LaTeX>
%    \end{macrocode}
%
% 
%    \begin{macrocode}
%<*LaTeX>
\NewDocumentEnvironment { DispWithArrows } { ! d < > ! O { } }
%</LaTeX>
%<*plain-TeX>
\cs_new_protected:Npn \DispWithArrows 
  {
    \group_begin:
    \peek_meaning:NTF <
      { \DispWithArrows_i }
      { \DispWithArrows_i < \c_novalue_tl > }
  }
\cs_new_protected:Npn \DispWithArrows_i < #1 > 
  {
    \peek_meaning:NTF [
      { \DispWithArrows_ii < #1 > }
      { \DispWithArrows_ii < #1 > [ ] }
  }
\cs_new_protected:Npn \DispWithArrows_ii < #1 > [ #2 ]
%</plain-TeX>
  { 
    \bool_set_true:N \l_@@_in_DispWithArrows_bool
%<*plain-TeX>
    \str_clear_new:N \l_@@_type_env_str
    \str_set:Nn \l_@@_type_env_str { DispWithArrows }
%</plain-TeX>
%    \end{macrocode}
% If \pkg{mathtools} has been loaded with the option |showonlyrefs|, we disable
% the code of \pkg{mathtools} for the option |showonlyrefs| with the command
% |\MT_showonlyrefs_false:| (it will be reactivated at the end of the
% environment). 
%    \begin{macrocode}
%<*LaTeX>
    \bool_if:nT \c_@@_mathtools_loaded_bool 
      { 
        \MH_if_boolean:nT { show_only_refs } 
          {
            \MT_showonlyrefs_false:
%    \end{macrocode}
% However, we have to re-raise the flag |{show_only_refs}| of \pkg{mhsetup}
% because it has been switched off by |\MT_showonlyrefs_false:| and we will use
% it in the code of the new version of |\label|.
%    \begin{macrocode}
            \MH_set_boolean_T:n { show_only_refs } 
          }
      }
%    \end{macrocode}
%
% An action done by \pkg{typedref} in its redefinition of |\refstepcounter|. The
% command |\sr@name| is a prefix added to the name of the label by the
% redefinition of |\label| done by \pkg{typedref}.
%    \begin{macrocode}
    \bool_if:NT \c_@@_typedref_loaded_bool { \str_set:Nn \sr@name { equation } }
%    \end{macrocode}
%
% The command |\intertext@| is a command of \pkg{amsmath} which loads the
% definition of |\intertext|.
%    \begin{macrocode}
    \bool_if:NT \c_@@_amsmath_loaded_bool \intertext@
%</LaTeX>
    \exp_args:No \tl_if_novalue:nF { #1 } { \tl_set:Nn \l_@@_left_brace_tl { #1 } }
    \@@_pre_halign:n { #2 }
%    \end{macrocode}
%
% If |subequations| is used, we encapsulate the environment in an
% environment |{subequations}| of \pkg{amsmath}.
%    \begin{macrocode}
%<*LaTeX>
    \bool_if:NT \l_@@_subequations_bool { \begin { subequations } }
%</LaTeX>
%    \end{macrocode}
% Since the version 1.16 of \pkg{witharrows}, no space is added between an
% |\item| of a LaTeX list and an environment |{DispWithArrows}| except with the
% option |standard-behaviour-with-items| stored in the boolean
% |\l_@@_sbwi_bool|. We have to know if we are just after an |\item| and this
% information will be stored in |\l_@@_in_label_or_minipage_bool|.
%    \begin{macrocode}
%<*LaTeX>
    \bool_if:NF \l_@@_sbwi_bool
      {  
        \if@inlabel
        \bool_set_true:N \l_@@_in_label_or_minipage_bool
        \fi
        \if@minipage
        \bool_set_true:N \l_@@_in_label_or_minipage_bool
        \fi
      }
%</LaTeX>
%    \end{macrocode}
%
%
%    \begin{macrocode}
    \tl_if_eq:NNF \l_@@_left_brace_tl \c_novalue_tl
      {
%    \end{macrocode}
% We compute the value of the width of the left delimiter.
%    \begin{macrocode}
        \hbox_set:Nn \l_tmpa_box 
          { 
%    \end{macrocode}
% Even if the default value of |\nulldelimiterspace| is 1.2~pt, we take it into account.
%    \begin{macrocode}
            \group_begin:
            \dim_set_eq:NN \nulldelimiterspace \c_zero_dim
            \c_math_toggle_token
            \left \l_@@_replace_left_brace_by_tl \vcenter to 1 cm { } \right.
            \c_math_toggle_token
            \group_end:
          }
        \dim_zero_new:N \l_@@_delim_wd_dim
        \dim_set:Nn \l_@@_delim_wd_dim { \box_wd:N \l_tmpa_box }
        \box_clear_new:N \l_@@_left_brace_box
        \hbox_set:Nn \l_@@_left_brace_box 
          { 
            \group_begin:
              \cs_set_eq:NN \label \@@_old_label
              \c_math_toggle_token
              \bool_if:NT \l_@@_displaystyle_bool \displaystyle 
              \l_@@_left_brace_tl
              { } 
              \c_math_toggle_token
            \group_end:
          }  
      }
%    \end{macrocode}
% 
% \bigskip
% The token list |\l_@@_tag_tl| will contain the argument of the command |\tag|.
%    \begin{macrocode}
%<*LaTeX>
    \tl_clear_new:N \l_@@_tag_tl
%    \end{macrocode}
% 
% \bigskip
%    \begin{macrocode}
    \bool_set_false:N \l_@@_qedhere_bool
%    \end{macrocode}
%
% \bigskip
% The boolean |\l_@@_tag_star_bool| will be raised if the user uses the command
% |\tag| with a star.
%    \begin{macrocode}
    \bool_set_false:N \l_@@_tag_star_bool
%</LaTeX>
%    \end{macrocode}
% 
%    \begin{macrocode}
    \if_mode_math:
      \@@_fatal:n { DispWithArrows~in~math~mode }
    \fi:
%    \end{macrocode}
%
% \bigskip
% The construction is not exactly the same whether we are just after an |\item|
% of a LaTeX list or not. We know if we are after an |\item| thanks to the
% boolean |\l_@@_in_label_or_minipage_bool|.
%    \begin{macrocode}
%<*plain-TeX>
     \dim_zero_new:N \linewidth
     \dim_set_eq:NN \linewidth \displaywidth
%</plain-TeX>
%<*LaTeX>
    \bool_if:NTF \l_@@_in_label_or_minipage_bool
      { \c_math_toggle_token } 
      {  
%</LaTeX>
%    \end{macrocode}
% We don't use |\[| of LaTeX because some extensions, like \pkg{autonum}, do a
% redefinition of |\[|. However, we put the following lines which are in the
% definition of |\[| even though they are in case of misuse.
%    \begin{macrocode}
        \if_mode_vertical:
        \nointerlineskip
        \hbox_to_wd:nn { .6 \linewidth } { }
        \fi:
        \c_math_toggle_token \c_math_toggle_token
%<*LaTeX>
      }
%</LaTeX>
%    \end{macrocode}
%
%    \begin{macrocode}
    \dim_zero_new:N \l_@@_linewidth_dim
%<*LaTeX>
    \bool_if:NTF \l_@@_in_label_or_minipage_bool 
       { \dim_set_eq:NN \l_@@_linewidth_dim \linewidth }
       { \dim_set_eq:NN \l_@@_linewidth_dim \displaywidth }
%</LaTeX>
%<*plain-TeX>
    \dim_set_eq:NN \l_@@_linewidth_dim \displaywidth
%</plain-TeX>
%    \end{macrocode}
%
% 
%    \begin{macrocode}
    \box_clear_new:N \l_@@_halign_box
    \setbox \l_@@_halign_box \vtop \bgroup
    \tabskip =
      \bool_if:NTF \l_@@_fleqn_bool
        \c_zero_skip 
        { 0 pt plus 1000 pt minus 1000 pt }
%    \end{macrocode}
%
%
%    \begin{macrocode}
    \@@_construct_halign:
    \tabskip = 0 pt plus 1000 pt minus 1000 pt
    & 
%    \end{macrocode}
%
% If the user tries to use more columns than the length of the format, we have to
% raise an error. However, the error won't be in the next column which is the
% columns for the labels of the equations. The error will be after... and it
% must be after. That means that we must not have an error in the next column
% simply because we are not in math mode. That's why this column, even if it is
% for the labels, is in math mode.
%    \begin{macrocode}
    $ ## $
    \tabskip = \c_zero_skip
    && 
    \@@_fatal:n { Too~much~columns~in~DispWithArrows } 
    \bool_if:nT \c_false_bool { ## }
    \cr
  }
%    \end{macrocode}
% 
% \bigskip
% We begin the second part of the environment |{DispWithArrows}|.
%    \begin{macrocode}
%<*plain-TeX>
\cs_new_protected:Npn \endDispWithArrows
%</plain-TeX>
  { 
%<*LaTeX>
    \clist_if_in:NnT \l_@@_tags_clist { last }
      { \clist_set:Nn \l_@@_tags_clist { all } }
%</LaTeX>
    \\
%    \end{macrocode}
% The following |\egroup| is for the |\halign|.
%    \begin{macrocode}
    \egroup 
    \unskip \unpenalty \unskip \unpenalty 
    \box_set_to_last:N \l_tmpa_box
    \nointerlineskip 
    \box_use:N \l_tmpa_box 
    \dim_gzero_new:N \g_@@_alignment_dim
    \dim_gset:Nn \g_@@_alignment_dim { \box_wd:N \l_tmpa_box }
    \box_clear_new:N \l_@@_new_box
    \hbox_set:Nn \l_@@_new_box { \hbox_unpack_clear:N \l_tmpa_box } 
    \dim_compare:nNnT 
      { \box_wd:N \l_@@_new_box } < \g_@@_alignment_dim
      { \dim_gset:Nn \g_@@_alignment_dim { \box_wd:N \l_@@_new_box } }
%    \end{macrocode}
% The |\egroup| is for the box |\l_@@_halign_box|.
%    \begin{macrocode}
    \egroup
%    \end{macrocode}
%
%    \begin{macrocode}
     \tl_if_eq:NNTF \l_@@_left_brace_tl \c_novalue_tl
       { \box_use_drop:N \l_@@_halign_box }
       { 
         \hbox_to_wd:nn \l_@@_linewidth_dim
           {
            \bool_if:NTF \l_@@_fleqn_bool
              { \skip_horizontal:n \l_@@_mathindent_dim }
              \hfil
            \hbox_to_wd:nn \g_@@_alignment_dim 
              { 
                \box_use_drop:N \l_@@_left_brace_box
                \dim_set:Nn \l_tmpa_dim 
                  { 
                    \box_ht:N \l_@@_halign_box
                    + \box_dp:N \l_@@_halign_box
                  }
                \group_begin:
                \dim_set_eq:NN \nulldelimiterspace \c_zero_dim
                \c_math_toggle_token
                  \left \l_@@_replace_left_brace_by_tl 
                    \vcenter to \l_tmpa_dim { \vfil } 
                  \right. 
                \c_math_toggle_token
                \group_end:
                \hfil
              }
            \hfil
           } 
         \skip_horizontal:n { - \l_@@_linewidth_dim } 
         \vcenter { \box_use_drop:N \l_@@_halign_box }
       }
%    \end{macrocode}
% 
% We compute the dimension |\g_@@_right_x_dim|. As a first approximation,
% |\g_@@_right_x_dim| is the $x$-value of the right side of the current
% composition box. In fact, we must take into account the potential labels of
% the equations. That's why we compute |\g_@@_right_x_dim| with the |v|-nodes of
% each row specifically built in this goal. |\g_@@_right_x_dim| is the minimal
% value of the $x$-value of these nodes.
%    \begin{macrocode}
    \dim_gzero_new:N \g_@@_right_x_dim 
    \dim_gset_eq:NN \g_@@_right_x_dim \c_max_dim
%<*LaTeX>
    \begin { tikzpicture } [ @@_standard ]
%</LaTeX>
%<*plain-TeX>
    \tikzpicture [ @@_standard ]
%</plain-TeX>
      \int_step_variable:nNn \g_@@_line_int \l_tmpa_int
        { 
          \cs_if_free:cTF 
            { pgf@sh@ns@wa - \l_@@_prefix_str - \l_tmpa_int - v }
            { \@@_fatal:n { Inexistent~v-node } }
            { 
              \tikz@parse@node\pgfutil@firstofone ( \l_tmpa_int - v )
              \dim_set:Nn \l_tmpa_dim \pgf@x
              \dim_compare:nNnT \l_tmpa_dim < \g_@@_right_x_dim
                { \dim_gset:Nn \g_@@_right_x_dim \l_tmpa_dim } 
            } 
        }
%<*LaTeX>
    \end { tikzpicture } 
%</LaTeX>
%<*plain-TeX>
    \endtikzpicture
%</plain-TeX>
%    \end{macrocode}
% 
%
% \bigskip
% The code in |\@@_post_halign:| is common to |{WithArrows}| and
% |{DispWithArrows}|.
%    \begin{macrocode}
    \@@_post_halign:
%    \end{macrocode}
% If \pkg{mathtools} has been loaded with the option |showonlyrefs|, we
% reactivate the code of \pkg{mathtools} for the option |showonlyrefs| with the
% command |\MT_showonlyrefs_true:| (it has been deactivated in the beginning of
% the environment).
%    \begin{macrocode}
%<*LaTeX>
    \bool_if:nT \c_@@_mathtools_loaded_bool
      { \MH_if_boolean:nT { show_only_refs } \MT_showonlyrefs_true: }
    \bool_if:NTF \l_@@_in_label_or_minipage_bool
      { 
        \c_math_toggle_token
        \skip_vertical:N \belowdisplayskip
      }
      { \c_math_toggle_token \c_math_toggle_token }
%</LaTeX>
%<*plain-TeX>
      \c_math_toggle_token \c_math_toggle_token
%</plain-TeX>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*LaTeX>
    \bool_if:NT \l_@@_subequations_bool { \end { subequations } }
%    \end{macrocode}
%
% \bigskip 
% If the option |footnote| or the option |footnotehyper| is used, then we
% extract the footnotes with an environment |{savenotes}| (of the package
% \pkg{footnote} or the package \pkg{footnotehyper}).
%    \begin{macrocode}
    \bool_if:NT \g_@@_footnote_bool { \end { savenotes } }
%</LaTeX>
%<*plain-TeX>
    \group_end:
%</plain-TeX>
%<*LaTeX>
    \ignorespacesafterend
%</LaTeX>
  }
%    \end{macrocode}
%
% \bigskip
% With the environment |{DispWithArrows*}|, the equations are not numbered. We
% don't put |\begin{DispWithArrows}| and |\end{DispWithArrows}| because there is
% a |\@currenvir| in some error messages.
%    \begin{macrocode}
%<*LaTeX>
\NewDocumentEnvironment { DispWithArrows* } { }
  { 
    \WithArrowsOptions { notag }
    \DispWithArrows
  }
  \endDispWithArrows
%</LaTeX>
%    \end{macrocode}
%
% 
% \bigskip
% \subsection{The commands \textbackslash tag, \textbackslash notag,
% \textbackslash label, \textbackslash tagnextline and \textbackslash qedhere for
% \{DispWithArrows\}} 
%
% Some commands are allowed only in the last column of the environment
% |{DispWithArrows}|. We write a command |\@@_if_in_last_col_of_disp:Nn| to
% execute this command only if we are in the last column. If we are in 
% another column, an error is raised. The first argument of
% |\@@_if_in_last_col_of_disp:Nn| is the name of the command used in the error
% message and the second is the code to execute.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_if_in_last_col_of_disp:Nn #1 #2
  { 
    \bool_if:NTF \l_@@_in_WithArrows_bool
      { \@@_error:nn { Not~allowed~in~WithArrows } { #1 } }
      { 
        \int_compare:nNnTF \g_@@_col_int < \l_@@_nb_cols_int
          { \@@_error:nn { Not~allowed~in~DispWithArrows } { #1 } }
          { #2 }
      }
  }
%    \end{macrocode}
% 
% \bigskip 
% The command |\@@_notag:| will be linked to the command |\notag| in
% the environments |{WithArrows}| and |{DispWithArrows}|.
%    \begin{macrocode}
%<*LaTeX>
\cs_new_protected:Npn \@@_notag: 
  { \@@_if_in_last_col_of_disp:Nn \notag { \clist_clear:N \l_@@_tags_clist } }
%    \end{macrocode}
% 
% \bigskip
% The command |\@@_nonumber:| will be linked to the command |\nonumber| 
% in the environments |{WithArrows}| and |{DispWithArrows}|. 
%    \begin{macrocode}
\cs_new_protected:Npn \@@_nonumber: 
  { \@@_if_in_last_col_of_disp:Nn \nonumber { \clist_clear:N \l_@@_tags_clist } }
%    \end{macrocode}
%
% \bigskip 
% The command |\@@_tag| will be linked to |\tag| in |{WithArrows}| and
% |{DispWithArrows}|. We do the definition with |\NewDocumentCommand| because this
% command has a starred version.
%    \begin{macrocode}
\NewDocumentCommand \@@_tag { s m } 
  { 
    \@@_if_in_last_col_of_disp:Nn \tag
      { 
        \tl_if_empty:NF \l_@@_tag_tl
          { \@@_error:nn  { Multiple~tags } { #2 } }
        \clist_set:Nn \l_@@_tags_clist { all }
        \bool_if:nT \c_@@_mathtools_loaded_bool
          {
            \MH_if_boolean:nT { show_only_refs }
              {
                \MH_if_boolean:nF { show_manual_tags }
                  { \clist_clear:N \l_@@_tags_clist }
              }
          }
        \tl_set:Nn \l_@@_tag_tl { #2 }
        \bool_set:Nn \l_@@_tag_star_bool { #1 }
%    \end{macrocode}
% The starred version |\tag*| can't be used if \pkg{amsmath} has not been loaded
% because this version does the job by deactivating the command |\tagform@|
% inserted by \pkg{amsmath} in the (two versions of the) command
% |\@eqnnum|.\footnote{There are two versions of |@eqnnum|, a standard version
% and a version for the option |leqno|.}
%    \begin{macrocode}
        \bool_if:nT { #1 && ! \bool_if_p:N \c_@@_amsmath_loaded_bool }
          { \@@_error:n { tag*~without~amsmath } } 
      }
  }
%    \end{macrocode}
%
% \bigskip
% The command |\@@_label:n| will be linked to |\label| in the environments
% |{WithArrows}| and |{DispWithArrows}|. In these environments, it's possible to
% put several labels for the same line (it's not possible in the environments of
% \pkg{amsmath}). That's why we store the differents labels of a same line in a
% sequence |\l_@@_labels_seq|.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_label:n #1
  {  
    \@@_if_in_last_col_of_disp:Nn \label
      { 
        \seq_if_empty:NF \l_@@_labels_seq 
          { 
            \bool_if:NTF \c_@@_cleveref_loaded_bool
              { \@@_error:n { Multiple~labels~with~cleveref } }
              { \@@_error:n { Multiple~labels } } 
          }
        \seq_put_right:Nn \l_@@_labels_seq { #1 }
        \bool_if:nT \c_@@_mathtools_loaded_bool
          {
            \MH_if_boolean:nT { show_only_refs } 
              { 
                \cs_if_exist:cTF { MT_r_#1 }
                  { \clist_set:Nn \l_@@_tags_clist { all } }
                  { \clist_clear:N \l_@@_tags_clist } 
              }
          }
        \bool_if:nT \c_@@_autonum_loaded_bool
          { 
            \cs_if_exist:cTF { autonum@#1Referenced }
              { \clist_set:Nn \l_@@_tags_clist { all } }
              { \clist_clear:N \l_@@_tags_clist } 
          } 
      } 
  }
%    \end{macrocode}
%
% \bigskip
% The command |\@@_tagnextline:| will be linked to |\tagnextline| in 
% |{DispWithArrows}|.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_tagnextline:
  { 
    \@@_if_in_last_col_of_disp:Nn \tagnextline
      { \bool_set_true:N \l_@@_tag_next_line_bool }
  }
%    \end{macrocode}
%
%
% \bigskip
% The environments |{DispWithArrows}| and |{DispWithArrows*}| are compliant with
% the command |\qedhere| of \pkg{amsthm}. However, this compatibility requires a
% special version of |\qedhere|.
% 
% This special version is called |\@@_qedhere:| and will be linked with
% |\qedhere| in the last column of the environment |{DispWithArrows}| (only if
% the package \pkg{amsthm} has been loaded). |\@@_qedhere:| raises the boolean
% |\l_@@_qedhere_bool|.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_qedhere: { \bool_set_true:N \l_@@_qedhere_bool }
\cs_new_protected:Npn \@@_set_qedhere: { \cs_set_eq:NN \qedhere \@@_qedhere: }  
%    \end{macrocode}
%
% In the last column of the |\halign| of |{DispWithArrows}| (column of the
% labels, that is to say the numbers of the equations), a command
% |\@@_qedhere_i:| will be issued if the flag |\l_@@_qedhere_bool| has been
% raised. The code of this command is an adaptation of the code of |\qedhere| in
% \pkg{amsthm}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_qedhere_i: 
  {
    \group_begin:
      \cs_set_eq:NN \qed \qedsymbol
%    \end{macrocode}
% The line |\cs_set_eq:NN \qed@elt \setQED@elt| is a preparation for an action
% on the \textsc{qed} stack. Despite its form, the instruction |\QED@stack|
% executes an operation on the stack. This operation prints the \textsc{qed}
% symbol and nullify the top of the stack.
%    \begin{macrocode}
      \cs_set_eq:NN \qed@elt \setQED@elt 
      \QED@stack \relax \relax 
    \group_end: 
  }
%</LaTeX>
%    \end{macrocode}
% 
% 
%
%
% \subsection{We draw the arrows}
%
% \bigskip
% The arrows are divided in groups. There is two reasons for this division.
% \begin{itemize}[beginpenalty=10000]
% \item If the option |group| or the option |groups| is used, all the arrows of
% a group are drawn on a same vertical at an abscissa of |\l_@@_x_dim|.
% \item For aesthetic reasons, the starting point of all the starting arrows of
% a group is raised upwards by the value |\l_@@_start_adjust_dim|. Idem for the
% ending arrows.
% \end{itemize}
% 
% \medskip
% If the option |group| is used (|\l_@@_pos_arrow_int| = 7), we scan the arrows
% twice: in the first step we only compute the value of |\l_@@_x_dim| for the
% whole group, and, in the second step (|\l_@@_pos_arrow_int| is set to 8), we
% divide the arrows in groups (for the vertical adjustement) and we actually
% draw the arrows.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_scan_arrows:
  { 
    \group_begin:
    \int_compare:nNnT \l_@@_pos_arrow_int = 7
      { 
        \@@_scan_arrows_i:
        \int_set:Nn \l_@@_pos_arrow_int 8 
      }
    \@@_scan_arrows_i:
    \group_end:
  }
%    \end{macrocode}
% 
% \bigskip
%    \begin{macrocode}
\cs_new_protected:Npn \@@_scan_arrows_i:
  { 
%    \end{macrocode}
%
% \bigskip 
% |\l_@@_first_arrow_of_group_int| will be the first arrow of the current group.
%
% |\l_@@_first_line_of_group_int| will be the first line involved in the group
% of arrows (equal to the initial line of the first arrow of the group because
% the option |jump| is always positive).
%
% |\l_@@_first_arrows_seq| will be the list the arrows of the group starting at
% the first line of the group (we may have several arrows starting from the same
% line). We have to know all these arrows because of the adjustement by
% |\l_@@_start_adjust_dim|.
%
% |\l_@@_last_line_of_group_int| will be the last line involved in the group
% (impossible to guess in advance).
%
% |\l_@@_last_arrows_seq| will be the list of all the arrows of the group
% ending at the last line of the group (impossible to guess in advance).
%    \begin{macrocode}
    \int_zero_new:N \l_@@_first_arrow_of_group_int 
    \int_zero_new:N \l_@@_first_line_of_group_int
    \int_zero_new:N \l_@@_last_line_of_group_int
    \seq_clear_new:N \l_@@_first_arrows_seq
    \seq_clear_new:N \l_@@_last_arrows_seq
%    \end{macrocode}
%
% \medskip
% The boolean |\l_@@_new_group_bool| is a switch that we will use the indicate
% that a group is finished (and the lines of that group have to be drawn). This
% boolean is not directly connected to the option |new-group| of an individual
% arrow.
%    \begin{macrocode}
    \bool_set_true:N \l_@@_new_group_bool
%    \end{macrocode}
%
% \bigskip
% We begin a loop over all the arrows of the environment. Inside this loop, if a
% group is finished, we will draw the arrows of that group.
%    \begin{macrocode}
    \int_set:Nn \l_@@_arrow_int \c_one_int
    \int_until_do:nNnn \l_@@_arrow_int > \g_@@_arrow_int
      { 
%    \end{macrocode}
%
% \bigskip 
% We extract from the property list of the current arrow the fields ``initial'',
% ``final'', ``status'' and ``input-line''. For the two former, we have to do
% conversions to integers.
%    \begin{macrocode}
        \prop_get:cnN 
          { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop }
          { initial } \l_tmpa_tl
        \int_set:Nn \l_@@_initial_int \l_tmpa_tl
        \prop_get:cnN 
          { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop }
          { final } \l_tmpa_tl
        \int_set:Nn \l_@@_final_int \l_tmpa_tl
        \prop_get:cnN 
          { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop }
          { status } \l_@@_status_arrow_str
        \prop_get:cnN 
          { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop }
          { input-line } \l_@@_input_line_str
%    \end{macrocode}
%
% \bigskip
% We recall that, after the construction of the |\halign|, |\g_@@_line_int| is
% the total number of lines of the environment. Therefore, the conditionnal
% |\l_@@_final_int > \g_@@_line_int| tests whether an arrow arrives after the
% last line of the environment. In this case, we raise an error (except in the
% second step of treatment for the option |group|). The arrow will be completely
% ignored, even for the computation of |\l_@@_x_dim|.
%    \begin{macrocode}
        \int_compare:nNnTF \l_@@_final_int > \g_@@_line_int
          { 
            \int_compare:nNnF \l_@@_pos_arrow_int = 8
              { \@@_error:n { Too~few~lines~for~an~arrow } }
          }
          \@@_code_for_possible_arrow:
%    \end{macrocode}
%
% \bigskip
% Incrementation of the index of the loop (and end of the loop).
%    \begin{macrocode}
        \int_incr:N \l_@@_arrow_int
      }
%    \end{macrocode}
%
% \bigskip
% After the last arrow of the environment, we have to draw the last group of
% arrows. If we are in option |group| and in the first step of treatment
% (|\l_@@_pos_arrow_int| = 7), we don't draw because, in the first step, we
% don't draw anything. If there is no arrow in the group, we don't draw (this
% situation occurs when all the arrows of the potential group arrive after the
% last line of the environment).
%    \begin{macrocode}
    \bool_if:nT
      { 
        \int_compare_p:n { \l_@@_pos_arrow_int != 7 } 
          &&
        \int_compare_p:nNn \l_@@_first_arrow_of_group_int > 0 
      }
      { \@@_draw_arrows:nn \l_@@_first_arrow_of_group_int \g_@@_arrow_int }
  }
%    \end{macrocode}
%
% \bigskip
%    \begin{macrocode}
\cs_new_protected:Npn \@@_code_for_possible_arrow:
  { 
%    \end{macrocode}
% We test whether the previous arrow was in fact the last arrow of a group. In
% this case, we have to draw all the arrows of that group, except if we are with
% the option |group| and in the first step of treatment (|\l_@@_pos_arrow_int| =
% 7). 
%    \begin{macrocode}
    \bool_if:nT 
      { 
        \int_compare_p:nNn \l_@@_arrow_int > \c_one_int
        && 
       ( \int_compare_p:n { \l_@@_initial_int > \l_@@_last_line_of_group_int }
           &&
         \int_compare_p:n { \l_@@_pos_arrow_int != 7 }
           ||
         \str_if_eq_p:Vn \l_@@_status_arrow_str { new-group }
       ) 
      }
      { 
        \int_compare:nNnF \l_@@_first_arrow_of_group_int = \c_zero_int
          { 
            \@@_draw_arrows:nn 
              \l_@@_first_arrow_of_group_int 
              { \l_@@_arrow_int - 1 } 
          }
        \bool_set_true:N \l_@@_new_group_bool
      }
%    \end{macrocode}
%
% \bigskip 
% The flag |\l_@@_new_group_bool| indicates if we have to begin a new group of
% arrows. In fact, we have to begin a new group in three circonstancies: if we
% are at the first arrow of the environment (that's why the flag is raised
% before the beginning of the loop), if we have just finished a group (that's
% why the flag is raised in the previous conditionnal, for topological reasons
% or if the previous arrows had the status ``new-group''). At the beginning of a
% group, we have to initialize the following variables: |\l_@@_first_arrow_int|,
% |\l_@@_first_line_of_group_int|, |\l_@@_last_line_of_group|,
% |\l_@@_first_arrows_seq|, |\l_@@_last_arrows_seq|.
%
%    \begin{macrocode}
    \bool_if:nTF \l_@@_new_group_bool
      { 
        \bool_set_false:N \l_@@_new_group_bool
        \int_set_eq:NN \l_@@_first_arrow_of_group_int \l_@@_arrow_int
        \int_set_eq:NN \l_@@_first_line_of_group_int \l_@@_initial_int
        \int_set_eq:NN \l_@@_last_line_of_group_int \l_@@_final_int
        \seq_clear:N \l_@@_first_arrows_seq 
        \seq_put_left:NV \l_@@_first_arrows_seq \l_@@_arrow_int
        \seq_clear:N \l_@@_last_arrows_seq 
        \seq_put_left:NV \l_@@_last_arrows_seq \l_@@_arrow_int
%    \end{macrocode}
%
% If we are in option |group| and in the second step of treatment
% (|\l_@@_pos_arrow_int| = 8), we don't initialize |\l_@@_x_dim| because we want
% to use the same value of |\l_@@_x_dim| (computed during the first step) for
% all the groups.
%    \begin{macrocode}
        \int_compare:nT { \l_@@_pos_arrow_int != 8 }
          { \dim_set:Nn \l_@@_x_dim { - \c_max_dim } }
      }
%    \end{macrocode}
%
% \bigskip
% If we are not at the beginning of a new group.
%    \begin{macrocode}
      { 
%    \end{macrocode}
% 
% If the arrow is independent, we don't take into account this arrow for the
% detection of the end of the group.
%    \begin{macrocode}
        \bool_if:nF 
          { \str_if_eq_p:Vn \l_@@_status_arrow_str { independent } }
          { 
%    \end{macrocode}
% If the arrow is not independent, the arrow belongs to the current group and we
% have to take it into account in some variables.
%    \begin{macrocode}
            \int_compare:nT 
              { \l_@@_initial_int = \l_@@_first_line_of_group_int }
              { \seq_put_left:NV \l_@@_first_arrows_seq \l_@@_arrow_int }
            \int_compare:nNnTF \l_@@_final_int > \l_@@_last_line_of_group_int
              { 
                \int_set_eq:NN \l_@@_last_line_of_group_int \l_@@_final_int
                \seq_clear:N \l_@@_last_arrows_seq
                \seq_put_left:NV \l_@@_last_arrows_seq \l_@@_arrow_int
              }
              { 
                \int_compare:nNnT \l_@@_final_int = \l_@@_last_line_of_group_int
                  { \seq_put_left:NV \l_@@_last_arrows_seq \l_@@_arrow_int }
              }
          }
      }
%    \end{macrocode}
%
% \bigskip 
% If the arrow is not independent, we update the current $x$-value (in 
% |\l_@@_x_dim|) with the dedicated command |\@@_update_x:nn|. If we are
% in option |group| and in the second step of treatment (|\l_@@_pos_arrow_int| =
% 8), we don't initialize |\l_@@_x_dim| because we want to use the same value of
% |\l_@@_x_dim| (computed during the first step) for all the groups.
%    \begin{macrocode}
    \bool_if:nF { \str_if_eq_p:Vn \l_@@_status_arrow_str { independent } }
      { 
        \int_compare:nT { \l_@@_pos_arrow_int != 8 }
          { \@@_update_x:nn \l_@@_initial_int \l_@@_final_int }
      } 
  }
%    \end{macrocode}
%
%
% \bigskip
% The following code is necessary because we will have to expand an argument
% exactly 3 times.
%    \begin{macrocode}
\cs_generate_variant:Nn \keys_set:nn { n o }
\cs_new_protected:Npn \@@_keys_set: 
  { \keys_set_known:no { WithArrows / Arrow / SecondPass } }
%    \end{macrocode}
%
% \bigskip
% The macro |\@@_draw_arrows:nn| draws all the arrows whose numbers are between
% |#1| and |#2|. |#1| and |#2| must be expressions that expands to an integer
% (they are expanded in the beginning of the macro). This macro is nullified by
% the option |no-arrows|.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_draw_arrows:nn #1 #2
  {
    \group_begin:
    \int_zero_new:N \l_@@_first_arrow_int
    \int_set:Nn \l_@@_first_arrow_int { #1 }
    \int_zero_new:N \l_@@_last_arrow_int
    \int_set:Nn \l_@@_last_arrow_int { #2 }
%    \end{macrocode}
%
% \bigskip
% We begin a loop over the arrows we have to draw. The variable
% |\l_@@_arrow_int| (local in the environment |{WithArrows}|) will be used as
% index for the loop.
%    \begin{macrocode}
    \int_set:Nn \l_@@_arrow_int \l_@@_first_arrow_int
    \int_until_do:nNnn \l_@@_arrow_int > \l_@@_last_arrow_int
      {
%    \end{macrocode}
%
% \bigskip 
% We extract from the property list of the current arrow the fields ``initial''
% and ``final'' and we store these values in |\l_@@_initial_int| and
% |\l_@@_final_int|. However, we have to do a conversion because the components
% of a property list are token lists.
%    \begin{macrocode}
        \prop_get:cnN 
          { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop }
          { initial } \l_tmpa_tl
        \int_set:Nn \l_@@_initial_int \l_tmpa_tl
        \prop_get:cnN 
          { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop }
          { final } \l_tmpa_tl
        \int_set:Nn \l_@@_final_int \l_tmpa_tl
%    \end{macrocode}
%
% \bigskip
% If the arrow ends after the last line of the environment, we don't draw the
% arrow (an error has already been raised in |\@@_scan_arrows:|). We recall
% that, after the construction of the |\halign|, |\g_@@_line_int| is the total
% number of lines of the environment).
%    \begin{macrocode}
        \int_compare:nT { \l_@@_final_int <= \g_@@_line_int } \@@_draw_arrows_i:
        \int_incr:N \l_@@_arrow_int
      } 
    \group_end:
  }
%    \end{macrocode}
%
% \bigskip
% The macro |\@@_draw_arrows_i:| is only for the lisibility of the code. The
% first |\group_begin:| is for the options of the arrows (but we remind that the
% options |ll|, |rr|, |rl|, |lr|, |i| and |jump| have already been extracted and
% are not present in the field |options| of the property list of the arrow).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_draw_arrows_i:
  { 
    \group_begin:
%    \end{macrocode}
%
% \bigskip
% We process the options of the current arrow. The second argument of
% |\keys_set:nn| must be expanded exactly three times. An x-expansion is not
% possible because there can be tokens like |\bfseries| in the option |font| of
% the option |tikz|. This expansion is a bit tricky.
%    \begin{macrocode}
    \prop_get:cnN 
      { g_@@_arrow _\l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop } 
      { options } \l_tmpa_tl
    \str_clear_new:N \l_@@_previous_key_str
    \exp_args:NNo \exp_args:No 
    \@@_keys_set: { \l_tmpa_tl , tikz = { xshift = \l_@@_xoffset_dim } }
%    \end{macrocode}
%
% We create two booleans to indicate the position of the initial node and final
% node of the arrow in cases of options |rr|, |rl|, |lr| or |ll|:
%    \begin{macrocode}
    \bool_set_false:N \l_@@_initial_r_bool
    \bool_set_false:N \l_@@_final_r_bool
    \int_case:nn \l_@@_pos_arrow_int 
      {
        0 { \bool_set_true:N \l_@@_final_r_bool }
        2 { \bool_set_true:N \l_@@_initial_r_bool }
        3 
          { 
            \bool_set_true:N \l_@@_initial_r_bool
            \bool_set_true:N \l_@@_final_r_bool 
          }
      }
%    \end{macrocode}
%
% \bigskip
% \begin{center}
% \begin{tabular}{l}
% \begin{tabular}{@{}l*8c@{}}
% \toprule
% option & |lr| & |ll| & |rl| & |rr| & |v| & |i| & |groups| & |group| \\
% \midrule
% |\l_@@_pos_arrow_int| & $0$  & $1$  & $2$  & $3$  & $4$ & $5$  & $6$  & $7$ \\
% \bottomrule
% \end{tabular} \\
% \footnotesize The option |v| can be used only in |\Arrow| in |code-after| (see
% below). 
% \end{tabular}
% \end{center}
% 
% \bigskip
% In case of option |i| at a local or global level (|\l_@@_pos_arrow_int| = 5),
% we have to compute the $x$-value of the arrow (which is vertical). The
% computed $x$-value is stored in |\l_@@_x_dim| (the same variable used when the
% option |group| or the option |groups| is used).
%    \begin{macrocode}
    \int_compare:nNnT \l_@@_pos_arrow_int = 5
      { 
        \dim_set:Nn \l_@@_x_dim { - \c_max_dim }
        \@@_update_x:nn \l_@@_initial_int \l_@@_final_int 
      }
%    \end{macrocode}
%
% \bigskip
% |\l_@@_initial_tl| contains the name of the Tikz node from which the arrow
% starts (in normal cases... because with the option |i|, |group| and |groups|,
% the point will perhaps have another
% $x$-value --- but always the same $y$-value). Idem for |\l_@@_final_tl|.
%    \begin{macrocode}
    \tl_set:Nx \l_@@_initial_tl 
      { 
        \int_use:N \l_@@_initial_int - \bool_if:NTF \l_@@_initial_r_bool rl 
        .south 
      } 
    \tl_set:Nx \l_@@_final_tl 
      { \int_use:N \l_@@_final_int - \bool_if:NTF \l_@@_final_r_bool rl .north }
%    \end{macrocode}
% We use ``|.south|'' and ``|.north|'' because we want a small gap between two
% consecutive arrows (and the Tikz nodes created have the shape of small
% vertical segments: use option |show-nodes| to visualize the nodes).
%
% \bigskip
% The label of the arrow will be stored in |\l_tmpa_tl|.
%    \begin{macrocode}
    \prop_get:cnN 
      { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop } 
      { label } 
      \l_tmpa_tl 
%    \end{macrocode}
%
% \bigskip
% Now, we have to know if the arrow starts at the first line of the group and/or
% ends at the last line of the group. That's the reason why we have stored in
% |\l_@@_first_arrows_seq| the list of all the arrows starting at the
% first line of the group and in |\l_@@_last_arrows_seq| the list of
% all the arrows ending at the last line of the group. We compute these values
% in the booleans |\l_tmpa_bool| and |\l_tmpb_bool|. These computations can't be
% done in the following |{tikzpicture}| because the command |\seq_if_in:NnTF|
% which is \emph{not} expandable.
%    \begin{macrocode}
    \seq_if_in:NxTF \l_@@_first_arrows_seq 
      { \int_use:N \l_@@_arrow_int }
      { \bool_set_true:N \l_tmpa_bool }
      { \bool_set_false:N \l_tmpa_bool }
    \seq_if_in:NxTF \l_@@_last_arrows_seq 
      { \int_use:N \l_@@_arrow_int } 
      { \bool_set_true:N \l_tmpb_bool }
      { \bool_set_false:N \l_tmpb_bool }
    \int_compare:nNnT \l_@@_pos_arrow_int = 5
      { 
        \bool_set_true:N \l_tmpa_bool
        \bool_set_true:N \l_tmpb_bool 
      }
%    \end{macrocode}
%
% \bigskip 
% We compute and store in |\g_tmpa_tl| and |\g_tmpb_tl| the exact coordinates of
% the extremities of the arrow.
% \begin{itemize}[beginpenalty=10000]
% \item Concerning the
% $x$-values, the abscissa computed in |\l_@@_x_dim| will be used if the option
% of position is |i|, |group| or |groups|.
% \item Concerning the
% $y$-values, an adjustement is done for each arrow starting at the first line
% of the group and each arrow ending at the last line of the group (with the
% values of |\l_@@_start_adjust_dim| and |\l_@@_end_adjust_dim|).
% \end{itemize}
% 
%    \begin{macrocode}
    \dim_gzero_new:N \g_@@_x_initial_dim
    \dim_gzero_new:N \g_@@_x_final_dim
    \dim_gzero_new:N \g_@@_y_initial_dim
    \dim_gzero_new:N \g_@@_y_final_dim
%<*LaTeX>
    \begin { tikzpicture } [ @@_standard ]
%</LaTeX>
%<*plain-TeX>
    \tikzpicture [ @@_standard ]
%</plain-TeX>
      \tikz@scan@one@point \pgfutil@firstofone ( \l_@@_initial_tl )
      \dim_gset:Nn \g_@@_x_initial_dim \pgf@x
      \dim_gset:Nn \g_@@_y_initial_dim \pgf@y
      \tikz@scan@one@point \pgfutil@firstofone ( \l_@@_final_tl )
      \dim_gset:Nn \g_@@_x_final_dim \pgf@x
      \dim_gset:Nn \g_@@_y_final_dim \pgf@y
%<*LaTeX>
    \end { tikzpicture } 
%</LaTeX>
%<*plain-TeX>
    \endtikzpicture
%</plain-TeX>
    \bool_if:nTF
      { \dim_compare_p:nNn { \g_@@_y_initial_dim - \g_@@_y_final_dim }  
                                > \l_@@_max_length_of_arrow_dim 
        && 
        \int_compare_p:nNn { \l_@@_final_int - \l_@@_initial_int } = 1 
      }
      {
        \tl_gset:Nx \g_tmpa_tl 
          {
            \int_compare:nNnTF \l_@@_pos_arrow_int < 5
              { \dim_use:N \g_@@_x_initial_dim }
              { \dim_use:N \l_@@_x_dim } , 
            \dim_eval:n 
              { 
                ( \g_@@_y_initial_dim + \g_@@_y_final_dim ) / 2
                + ( \l_@@_max_length_of_arrow_dim / 2 )
              }
          }
        \tl_gset:Nx \g_tmpb_tl 
          {
            \int_compare:nNnTF \l_@@_pos_arrow_int < 5 
              { \dim_use:N \g_@@_x_final_dim }
              { \dim_use:N \l_@@_x_dim } , 
            \dim_eval:n 
              { 
                ( \g_@@_y_initial_dim + \g_@@_y_final_dim ) / 2
                - ( \l_@@_max_length_of_arrow_dim / 2 )
              }
          } 
      }
      {
        \tl_gset:Nx \g_tmpa_tl 
          {
            \int_compare:nNnTF \l_@@_pos_arrow_int < 5
              { \dim_use:N \g_@@_x_initial_dim }
              { \dim_use:N \l_@@_x_dim } , 
            \bool_if:NTF \l_tmpa_bool
              { \dim_eval:n { \g_@@_y_initial_dim + \l_@@_start_adjust_dim } }
              { \dim_use:N \g_@@_y_initial_dim } 
          }
        \tl_gset:Nx \g_tmpb_tl 
          {
            \int_compare:nNnTF \l_@@_pos_arrow_int < 5 
              { \dim_use:N \g_@@_x_final_dim }
              { \dim_use:N \l_@@_x_dim } , 
            \bool_if:NTF \l_tmpb_bool
              { \dim_eval:n { \g_@@_y_final_dim - \l_@@_end_adjust_dim } }
              { \dim_use:N \g_@@_y_final_dim } 
          } 
      }
%    \end{macrocode}
%
% \bigskip
% Eventually, we can draw the arrow with the code in |\l_@@_tikz_code_tl|. We
% recall that the value by default for this token list is :\enskip
% ``\verb|\draw (#1) to node {#3} (#2) ;|''. This value can be modified with the
% option |tikz-code|. We use the variant |\@@_draw_arrow:nno| of the macro
% |\@@_draw_arrow:nnn| because of the characters \emph{underscore} in the name
% |\l_tmpa_tl|: if the user uses the Tikz library |babel|, the third argument of
% the command |\@@_draw_arrow:nno| will be rescanned because this third argument
% will be in the argument of a command |node| of an instruction |\draw| of
% Tikz... and we will have an error because of the characters
% \emph{underscore}.\footnote{There were other solutions: use another name
% without \emph{underscore} (like \Verb|\ltmpatl|) or use the package
% \pkg{underscore} (with this package, the characters \emph{underscore} will be
% rescanned without errors, even in text mode).}
%    \begin{macrocode}
    \@@_draw_arrow:nno \g_tmpa_tl \g_tmpb_tl \l_tmpa_tl
%    \end{macrocode}
%
% \smallskip
% We close the TeX group opened for the options given to |\Arrow[...]| (local
% level of the options).
%    \begin{macrocode}
    \group_end: 
  }
%    \end{macrocode}
%
%
% \bigskip
% The function |@@_tmpa:nnn| will draw the arrow. It's merely an environment
% |{tikzpicture}|. However, the Tikz instruction in this environment must be
% inserted from |\l_@@_tikz_code_tl| with the markers |#1|, |#2| and |#3|.
% That's why we create a function |\@@_def_function_tmpa:n| which will create
% the function |\@@_tmpa:nnn|.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_def_function_tmpa:n #1
  { 
    \cs_set:Npn \@@_tmpa:nnn ##1 ##2 ##3
      { 
%<*LaTeX>
        \begin{tikzpicture} 
%</LaTeX>
%<*plain-TeX>
        \tikzpicture
%</plain-TeX>
          [ 
            @@_standard , 
            every~path / .style = WithArrows / arrow 
          ] 
          #1 
%<*LaTeX>
        \end{tikzpicture}
%</LaTeX>
%<*plain-TeX>
        \endtikzpicture
%</plain-TeX>
      }
  }
%    \end{macrocode}
%
% \medskip
% When we draw the arrow (with |\@@_draw_arrow:nnn|), we first create the
% function |\@@_tmpa:nnn| and, then, we use the function |\@@_tmpa:nnn| :
%    \begin{macrocode}
\cs_new_protected:Npn \@@_draw_arrow:nnn #1 #2 #3
  {
%    \end{macrocode}
%
% \medskip
% If the option |wrap-lines| is used, we have to use a special version of
% |\l_@@_tikz_code_tl| (which corresponds to the option |tikz-code|).
%    \begin{macrocode}
    \bool_if:nT { \l_@@_wrap_lines_bool && \l_@@_in_DispWithArrows_bool }
       { \tl_set_eq:NN \l_@@_tikz_code_tl \c_@@_tikz_code_wrap_lines_tl }
%    \end{macrocode}
% 
% \medskip
% Now, the main lines of this function |\@@_draw_arrow:nnn|.
%    \begin{macrocode}
    \exp_args:NV \@@_def_function_tmpa:n \l_@@_tikz_code_tl
    \@@_tmpa:nnn { #1 } { #2 } { #3 } 
  }
\cs_generate_variant:Nn \@@_draw_arrow:nnn { n n o }
%    \end{macrocode}
% 
% \bigskip
% If the option |wrap-lines| is used, we have to use a special version of
% |\l_@@_tikz_code_tl| (which corresponds to the option |tikz-code|).
%    \begin{macrocode}
\tl_const:Nn \c_@@_tikz_code_wrap_lines_tl
  { 
%    \end{macrocode}
% First, we draw the arrow without the label.
%    \begin{macrocode}
    \draw ( #1 ) to node ( @@_label ) { } ( #2 ) ;
%    \end{macrocode}
% We retrieve in |\pgf@x| the abscissa of the left-side of the label we will
% put.
%    \begin{macrocode}
    \tikz@parse@node \pgfutil@firstofone ( @@_label.west )
%    \end{macrocode}
% We compute in |\l_tmpa_dim| the maximal width possible for the label. 
% Here is the use of |\g_@@_right_x_dim| which has been computed previously with
% the |v|-nodes. 
%    \begin{macrocode}
    \dim_set:Nn \l_tmpa_dim 
      { \g_@@_right_x_dim - \pgf@x - \pgfkeysvalueof { / pgf / inner~xsep } } 
%    \end{macrocode}
% We retrieve in |\g_tmpa_tl| the current value of the Tikz parameter 
% ``|text width|''.\footnote{In fact, it's not the current value of 
% ``|text width|'': it's the value of ``|text width|'' set in the option |tikz|
% provided by \pkg{witharrows}. These options are given to Tikz in a 
% ``|every path|''. That's why we have to retrieve it in a path.}
%    \begin{macrocode}
    \path \pgfextra { \tl_gset:Nx \g_tmpa_tl \tikz@text@width } ;
%    \end{macrocode}
% Maybe the current value of the parameter ``|text width|'' is shorter than
% |\l_tmpa_dim|. In this case, we must use ``|text width|'' (we update
% |\l_tmpa_dim|).
%    \begin{macrocode}
    \tl_if_empty:NF \g_tmpa_tl
      {
        \dim_set:Nn \l_tmpb_dim \g_tmpa_tl
        \dim_compare:nNnT \l_tmpb_dim < \l_tmpa_dim
          { \dim_set_eq:NN \l_tmpa_dim \l_tmpb_dim }
      }
%    \end{macrocode}
% Now, we can put the label with the right value for ``|text width|''.
%    \begin{macrocode}
    \dim_compare:nNnT \l_tmpa_dim > \c_zero_dim
      { 
        \path ( @@_label.west ) 
           node [ anchor = west , text~width = \dim_use:N \l_tmpa_dim ] 
                { #3 } ; 
      } 
  }
%    \end{macrocode}
% 
% \bigskip
% The command |\@@_update_x:nn| will analyze the lines between |#1| and
% |#2| in order to modify |\l_@@_x_dim| in consequence. More precisely,
% |\l_@@_x_dim| is increased if a line longer than the current value of
% |\l_@@_x_dim| is found. |\@@_update_x:nn| is used in |\@@_scan_arrows:|
% (for options |group| and |groups|) and in |\@@_draw_arrows:nn| (for option
% |i|).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_update_x:nn #1 #2
  { 
    \int_step_inline:nnn { #1 } { #2 } 
      { 
%<*LaTeX>
        \begin { tikzpicture } [ @@_standard ]
%</LaTeX>
%<*plain-TeX>
        \tikzpicture [ @@_standard ]
%</plain-TeX>
          \tikz@scan@one@point \pgfutil@firstofone ( ##1 - l )
          \dim_gset:Nn \g_tmpa_dim { \dim_max:nn \l_@@_x_dim \pgf@x }
%<*LaTeX>
        \end { tikzpicture }
%</LaTeX>
%<*plain-TeX>
        \endtikzpicture
%</plain-TeX>
        \dim_set_eq:NN \l_@@_x_dim \g_tmpa_dim 
      } 
  } 
%    \end{macrocode}
%
%
% \bigskip
% The command |\WithArrowsLastEnv| is not used by the package \pkg{witharrows}.
% It's only a facility given to the final user. It gives the number of the last
% environment |{WithArrows}| at
% level~$0$ (to the sense of the nested environments). This macro is fully
% expandable and, thus, can be used directly in the name of a Tikz node.
%    \begin{macrocode}
\cs_new:Npn \WithArrowsLastEnv { \int_use:N \g_@@_last_env_int }
%    \end{macrocode}
%
% \bigskip
% \subsection{The command \textbackslash Arrow in code-after}
%
% The option |code-after| is an option of the environment |{WithArrows}| (this
% option is only available at the environment level). In the option |code-after|,
% one can use the command |Arrow| but it's a special version of the command
% |Arrow|. For this special version (internally called |\@@_Arrow_code_after|),
% we define a special set of keys called |WithArrows/Arrow/code-after|.
%
%    \begin{macrocode}
\keys_define:nn { WithArrows / Arrow / code-after }
  {
    tikz     .code:n = 
      \tikzset { WithArrows / arrow / .append~style = { #1 } } ,
    tikz     .value_required:n  = true ,
    rr       .value_forbidden:n = true ,
    rr       .code:n            = \@@_fix_pos_option:n 0 ,
    ll       .value_forbidden:n = true,
    ll       .code:n            = \@@_fix_pos_option:n 1 ,
    rl       .value_forbidden:n = true ,
    rl       .code:n            = \@@_fix_pos_option:n 2 ,
    lr       .value_forbidden:n = true ,
    lr       .code:n            = \@@_fix_pos_option:n 3 ,
    v        .value_forbidden:n = true ,
    v        .code:n            = \@@_fix_pos_option:n 4 ,
    tikz-code .tl_set:N          = \l_@@_tikz_code_tl ,
    tikz-code .value_required:n  = true ,
    xoffset  .dim_set:N         = \l_@@_xoffset_dim ,
    xoffset  .value_required:n  = true ,
    unknown .code:n  = 
      \@@_sort_seq:N \l_@@_options_Arrow_code_after_seq
      \@@_error:n { Unknown~option~Arrow~in~code-after } 
  }
%    \end{macrocode}
%
% \bigskip
% A sequence of the options available in |\Arrow| in |code-after|. This sequence
% will be used in the error messages and can be modified dynamically.
%    \begin{macrocode}
\seq_new:N \l_@@_options_Arrow_code_after_seq
\@@_set_seq_of_str_from_clist:Nn \l_@@_options_Arrow_code_after_seq
  { ll, lr, rl, rr, tikz, tikz-code, v, x, offset }
%    \end{macrocode}
% 
% \bigskip
%    \begin{macrocode}
%<*LaTeX>
\NewDocumentCommand \@@_Arrow_code_after { O { } m m m ! O { } }
%</LaTeX>
%<*plain-TeX>
\cs_new_protected:Npn \@@_Arrow_code_after 
  { 
    \peek_meaning:NTF [
      { \@@_Arrow_code_after_i }
      { \@@_Arrow_code_after_i [ ] }
  }
\cs_new_protected:Npn \@@_Arrow_code_after_i [ #1 ] #2 #3 #4
  {
    \peek_meaning:NTF [
      { \@@_Arrow_code_after_ii [ #1 ] { #2 } { #3 } { #4 } }
      { \@@_Arrow_code_after_ii [ #1 ] { #2 } { #3 } { #4 } [ ] }
  } 
\cs_new_protected:Npn \@@_Arrow_code_after_ii [ #1 ] #2 #3 #4 [ #5 ]
%</plain-TeX>
  {
    \int_set:Nn \l_@@_pos_arrow_int 1
    \str_clear_new:N \l_@@_previous_key_str
    \group_begin:
      \keys_set:nn { WithArrows / Arrow / code-after } 
        { #1, #5, tikz = { xshift = \l_@@_xoffset_dim } }
      \bool_set_false:N \l_@@_initial_r_bool
      \bool_set_false:N \l_@@_final_r_bool
      \int_case:nn \l_@@_pos_arrow_int
        { 
          0
            { 
              \bool_set_true:N \l_@@_initial_r_bool
              \bool_set_true:N \l_@@_final_r_bool
            }
          2 { \bool_set_true:N \l_@@_initial_r_bool }
          3 { \bool_set_true:N \l_@@_final_r_bool } 
        }
%    \end{macrocode}
% We prevent drawing an arrow from a line to itself.
%    \begin{macrocode}
      \tl_if_eq:nnTF { #2 } { #3 }
        { \@@_error:nn { Both~lines~are~equal } { #2 } }
%    \end{macrocode}
% We test whether the two Tikz nodes |(#2-l)| and |(#3-l)| really exist. If not, 
% the arrow won't be drawn.
%    \begin{macrocode}
        {
          \cs_if_free:cTF { pgf@sh@ns@wa - \l_@@_prefix_str - #2 - l }
            { \@@_error:nx { Wrong~line~in~Arrow } { #2 } }
            { 
              \cs_if_free:cTF { pgf@sh@ns@wa - \l_@@_prefix_str - #3 - l }
                { \@@_error:nx { Wrong~line~in~Arrow } { #3 }  }
                { 
                  \int_compare:nNnTF \l_@@_pos_arrow_int = 4
                    {
%<*LaTeX>
                      \begin { tikzpicture } [ @@_standard ]
%</LaTeX>
%<*plain-TeX>
                      \tikzpicture [ @@_standard ]
%</plain-TeX>
                        \tikz@scan@one@point \pgfutil@firstofone (#2-l.south)
                        \dim_set_eq:NN \l_tmpa_dim \pgf@x
                        \dim_set_eq:NN \l_tmpb_dim \pgf@y
                        \tikz@scan@one@point \pgfutil@firstofone (#3-l.north)
                        \dim_set:Nn \l_tmpa_dim 
                          { \dim_max:nn \l_tmpa_dim \pgf@x }
                        \tl_gset:Nx \g_tmpa_tl 
                          { \dim_use:N \l_tmpa_dim , \dim_use:N \l_tmpb_dim } 
                        \tl_gset:Nx \g_tmpb_tl 
                          { \dim_use:N \l_tmpa_dim , \dim_use:N \pgf@y } 
%<*LaTeX>
                      \end { tikzpicture } 
%</LaTeX>
%<*plain-TeX>
                      \endtikzpicture
%</plain-TeX>
                    }
                    { 
%<*LaTeX>
                      \begin { tikzpicture } [ @@_standard ]
%</LaTeX>
%<*plain-TeX>
                      \tikzpicture [ @@_standard ]
%</plain-TeX>
                        \tikz@scan@one@point \pgfutil@firstofone
                           ( #2-\bool_if:NTF\l_@@_initial_r_bool rl .south )
                        \tl_gset:Nx \g_tmpa_tl 
                           { \dim_use:N \pgf@x , \dim_use:N \pgf@y }
                        \tikz@scan@one@point \pgfutil@firstofone
                           ( #3-\bool_if:NTF\l_@@_final_r_bool rl .north )
                        \tl_gset:Nx \g_tmpb_tl 
                           { \dim_use:N \pgf@x , \dim_use:N \pgf@y }
%<*LaTeX>
                      \end { tikzpicture } 
%</LaTeX>
%<*plain-TeX>
                      \endtikzpicture
%</plain-TeX>
                    }
                  \@@_draw_arrow:nnn \g_tmpa_tl \g_tmpb_tl { #4 } 
                } 
            }
        }
    \group_end:
  }
%    \end{macrocode}
%
%                               
% \bigskip
% \subsection{The command \textbackslash MultiArrow in code-after}
% The command |\@@_MultiArrow:nn| will be linked to |\MultiArrow| when the
% |code-after| is executed.
%    
%    \begin{macrocode}
\cs_new_protected:Npn \@@_MultiArrow:nn #1 #2
  {  
%    \end{macrocode}
% The user of the command |\MultiArrow| (in |code-after|) will be able to specify
% the list of lines with the same syntax as the loop |\foreach| of \pkg{pgffor}.
% First, we test with a regular expression whether the format of the list of
% lines is correct.
%    \begin{macrocode}
    \exp_args:Nnx 
      \regex_match:nnTF 
      { \A \d+ (\,\d+)* ( \, \.\.\. (\,\d+)+ )* \Z }  
      { #1 } 
      { \@@_MultiArrow_i:nn { #1 } { #2 } }    
      { \@@_error:nx { Invalid~specification~for~MultiArrow } { #1 } }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_MultiArrow_i:nn #1 #2
  {
%    \end{macrocode}
% That's why we construct a ``clist'' of \pkg{expl3} from the specification of
% list given by the user. The construction of the ``clist'' must be global in
% order to exit the |\foreach| and that's why we will construct the list in
% |\g_tmpa_clist|.
%    \begin{macrocode}
    \foreach \x in { #1 }
      { 
        \cs_if_free:cTF { pgf@sh@ns@wa - \l_@@_prefix_str - \x - l }
          { \@@_error:nx { Wrong~line~specification~in~MultiArrow } \x }
          { \clist_gput_right:Nx \g_tmpa_clist \x } 
      } 
%    \end{macrocode}
% We sort the list |\g_tmpa_clist| because we want to extract the minimum and
% the maximum.
%    \begin{macrocode}
    \int_compare:nTF { \clist_count:N \g_tmpa_clist < 2 }
      { \@@_error:n { Too~small~specification~for~MultiArrow } }
      {
        \clist_sort:Nn \g_tmpa_clist 
          {
            \int_compare:nTF { ##1 > ##2 }
              \sort_return_swapped: 
              \sort_return_same:
          }
%    \end{macrocode}
% We extract the minimum in |\l_tmpa_tl| (it must be an integer but we store it
% in a token list of \pkg{expl3}).
%    \begin{macrocode}
        \clist_pop:NN \g_tmpa_clist \l_tmpa_tl
%    \end{macrocode}
%
% We extract the maximum in |\l_tmpb_tl|. The remaining list (in
% |\g_tmpa_clist|) will be sorted in decreasing order but never mind...
%    \begin{macrocode}
        \clist_reverse:N \g_tmpa_clist
        \clist_pop:NN \g_tmpa_clist \l_tmpb_tl
%    \end{macrocode}
%
% We draw the teeth of the rak (except the first one and the last one) with the
% auxiliary function |\@@_MultiArrow_i:n|. This auxiliary fonction is necessary
% to expand the specification of the list in the |\foreach| loop. The first and
% the last teeth of the rak can't be drawn the same way as the others (think,
% for example, to the case of the option ``|rounded corners|'' is used).
%    \begin{macrocode}
        \exp_args:NV \@@_MultiArrow_i:n \g_tmpa_clist
%    \end{macrocode}
%
% Now, we draw the rest of the structure.
%    \begin{macrocode}
%<*LaTeX>
        \begin { tikzpicture }
%</LaTeX>
%<*plain-TeX>
        \tikzpicture
%</plain-TeX>
          [ 
            @@_standard , 
            every~path / .style = { WithArrows / arrow } 
          ] 
          \draw [<->] ([xshift = \l_@@_xoffset_dim]\l_tmpa_tl-r.south)
                      -- ++(5mm,0)
                      -- node (@@_label) {} 
                         ([xshift = \l_@@_xoffset_dim+5mm]\l_tmpb_tl-r.south)
                      -- ([xshift = \l_@@_xoffset_dim]\l_tmpb_tl-r.south)  ;
          \tikz@parse@node \pgfutil@firstofone (@@_label.west)
          \dim_set:Nn \l_tmpa_dim { 20 cm }
          \path \pgfextra { \tl_gset:Nx \g_tmpa_tl \tikz@text@width } ;
          \tl_if_empty:NF \g_tmpa_tl { \dim_set:Nn \l_tmpa_dim \g_tmpa_tl }
          \bool_if:nT { \l_@@_wrap_lines_bool && \l_@@_in_DispWithArrows_bool }
            { 
              \dim_set:Nn \l_tmpb_dim 
                { \g_@@_right_x_dim - \pgf@x - 0.3333 em }
              \dim_compare:nNnT \l_tmpb_dim < \l_tmpa_dim
                { \dim_set_eq:NN \l_tmpa_dim \l_tmpb_dim } 
            }
          \path (@@_label.west) 
           node [ anchor = west, text~width = \dim_use:N \l_tmpa_dim ] { #2 } ;
%<*LaTeX>
        \end{tikzpicture} 
%</LaTeX>
%<*plain-TeX>
        \endtikzpicture
%</plain-TeX>
      } 
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_MultiArrow_i:n #1
  { 
%<*LaTeX>
        \begin { tikzpicture }
%</LaTeX>
%<*plain-TeX>
        \tikzpicture
%</plain-TeX>
      [ 
        @@_standard , 
        every~path / .style = { WithArrows / arrow } 
      ] 
      \foreach \k in { #1 }
        { 
          \draw [ <- ] 
            ( [xshift = \l_@@_xoffset_dim]\k-r.south ) -- ++(5mm,0) ; 
        } ;
%<*LaTeX>
        \end{tikzpicture} 
%</LaTeX>
%<*plain-TeX>
        \endtikzpicture
%</plain-TeX>
  }
%    \end{macrocode}
%
%
% \bigskip
% \subsection{The error messages of the package}
%
%    \begin{macrocode}
\str_const:Nn \c_@@_option_ignored_str
  { If~you~go~on,~this~option~will~be~ignored. }
\str_const:Nn \c_@@_command_ignored_str
  { If~you~go~on,~this~command~will~be~ignored. }
%    \end{macrocode}
%
%    \begin{macrocode}
%<*LaTeX>
\@@_msg_new:nn { amsmath~not~loaded }
  {
    You~can't~use~the~option~'\l_keys_key_tl'~because~the~
    package~'amsmath'~has~not~been~loaded.\\
    If~you~go~on,~this~option~will~be~ignored~in~the~rest~
    of~the~document.
  }
%</LaTeX>
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Bad~value~for~replace~brace~by }
  {
    Bad~value~for~the~option~'\l_keys_key_tl'.~The~value~must~begin~ 
    with~an~extensible~left~delimiter.~The~possible~values~are:~.,
    \token_to_str:N \{,~(,~[,~\token_to_str:N \lbrace,~
    \token_to_str:N \lbrack,~\token_to_str:N \lgroup,~
    \token_to_str:N \langle,~\token_to_str:N \lmoustache,~
    \token_to_str:N \lfloor\ and~\token_to_str:N \lceil\ 
    (and~\token_to_str:N \lvert\ and~\token_to_str:N \lVert\
    if~amsmath~or~unicode-math~is~loaded~in~LaTeX).\\
    \c_@@_option_ignored_str 
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { option~of~cr~negative }
  {
    The~argument~of~the~command~\token_to_str:N\\~
    should~be~positive~in~the~row~\int_use:N \g_@@_line_int\
    of~your~environment~\{\l_@@_type_env_str\}.\\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
% 
%    \begin{macrocode}
\@@_msg_new:nn { omit~probably~used } 
  {
    There~is~a~problem.~Maybe~you~have~used~a~command~
    \token_to_str:N\omit\ in~the~line~\int_use:N \g_@@_line_int\
    (or~another~line)~of~your~environment~\{\l_@@_type_env_str\}.\\ 
    You~can~go~on~but~you~may~have~others~errors.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<*LaTeX>
\@@_msg_new:nn { newline~at~the~end~of~env }
  { 
    The~environments~of~witharrows~(\{WithArrows\}~and~
    \{DispWithArrows\})~should~not~end~by~\token_to_str:N \\.\\
    However,~you~can~go~on~for~this~time.~No~similar~error~will~be~
    raised~in~this~document.
  }
%</LaTeX>
%    \end{macrocode}    
%
%    \begin{macrocode}
\@@_msg_new:nn { Invalid~option~format }
  {
    The~key~'format'~should~contain~only~letters~r,~c~and~l~and~
    must~not~be~empty.\\  
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Value~for~a~key }
  {
    The~key~'\l_keys_key_tl'~should~be~used~without~value. \\
    However,~you~can~go~on~for~this~time.
  }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nnn { Unknown~option~in~Arrow }
  { 
    The~key~'\l_keys_key_tl'~is~unknown~for~the~command~
    \l_@@_string_Arrow_for_msg_str\ in~the~row~
    \int_use:N \g_@@_line_int\ of~your~environment~
    \{\l_@@_type_env_str\}. \l_tmpa_str \\
    \c_@@_option_ignored_str \\
    For~a~list~of~the~available~keys,~type~H~<return>.
  }
  { 
    The~available~keys~are~(in~alphabetic~order):~
    \seq_use:Nnnn \l_@@_options_Arrow_seq {~and~} {,~} {~and~}.
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}          
\@@_msg_new:nnn { Unknown~option~WithArrows }
  {
    The~key~'\l_keys_key_tl'~is~unknown~in~\{\l_@@_type_env_str\}. \\
    \c_@@_option_ignored_str \\
    For~a~list~of~the~available~keys,~type~H~<return>.
  }
  {
    The~available~keys~are~(in~alphabetic~order):~
    \seq_use:Nnnn \l_@@_options_WithArrows_seq {~and~} {,~} {~and~}.
  }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nnn { Unknown~option~DispWithArrows }
  { 
    The~key~'\l_keys_key_tl'~is~unknown~in~\{\l_@@_type_env_str\}. \\
    \c_@@_option_ignored_str \\
    For~a~list~of~the~available~keys,~type~H~<return>.
  }
  {
    The~available~keys~are~(in~alphabetic~order):~
    \seq_use:Nnnn \l_@@_options_DispWithArrows_seq {~and~} {,~} {~and~}.
  }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nnn { Unknown~option~WithArrowsOptions }
  { 
    The~key~'\l_keys_key_tl'~is~unknown~in~
    \token_to_str:N \WithArrowsOptions. \\
    \c_@@_option_ignored_str \\
    For~a~list~of~the~available~keys,~type~H~<return>. 
  }
  {
    The~available~keys~are~(in~alphabetic~order):~
    \seq_use:Nnnn \l_@@_options_WithArrowsOptions_seq {~and~} {,~} {~and~}.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nnn { Unknown~option~Arrow~in~code-after }
  { 
    The~key~'\l_keys_key_tl'~is~unknown~in~
    \token_to_str:N \Arrow\ in~code-after. \\
    \c_@@_option_ignored_str \\
    For~a~list~of~the~available~keys,~type~H~<return>.
  }
  { 
    The~available~keys~are~(in~alphabetic~order):~
    \seq_use:Nnnn \l_@@_options_Arrow_code_after_seq {~and~} {,~} {~and~}.
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}          
\@@_msg_new:nn { Too~much~columns~in~WithArrows }
  { 
    Your~environment~\{\l_@@_type_env_str\}~has~\int_use:N 
    \l_@@_nb_cols_int\ columns~and~you~try~to~use~one~more.~
    Maybe~you~have~forgotten~a~\c_backslash_str\c_backslash_str.~
    If~you~really~want~to~use~more~columns~(after~the~arrows)~you~should~use~ 
    the~option~'more-columns'~at~a~global~level~or~for~an~environment. \\
    However,~you~can~go~one~for~this~time.
  }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nn { Too~much~columns~in~DispWithArrows }
  { 
    Your~environment~\{\l_@@_type_env_str\}~has~\int_use:N 
    \l_@@_nb_cols_int\ columns~and~you~try~to~use~one~more.~
    Maybe~you~have~forgotten~a~\c_backslash_str\c_backslash_str\ 
    at~the~end~of~row~\int_use:N \g_@@_line_int. \\
    This~error~is~fatal.
  }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nn { Negative~jump }
  { 
    You~can't~use~a~negative~value~for~the~option~'jump'~of~command~
    \l_@@_string_Arrow_for_msg_str\
    in~the~row~\int_use:N \g_@@_line_int\
    of~your~environment~\{\l_@@_type_env_str\}.~
    You~can~create~an~arrow~going~backwards~with~the~option~'<-'~of~Tikz. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { new-group~without~groups }
  { 
    You~can't~use~the~option~'new-group'~for~the~command~
    \l_@@_string_Arrow_for_msg_str\
    because~you~are~not~in~'groups'~mode.~Try~to~use~the~option~
    'groups'~in~your~environment~\{\l_@@_type_env_str\}. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}          
\@@_msg_new:nn          
  { Too~few~lines~for~an~arrow }
  { 
    Line~\l_@@_input_line_str\
    :~an~arrow~specified~in~the~row~\int_use:N \l_@@_initial_int\
    of~your~environment~\{\l_@@_type_env_str\}~can't~be~drawn~
    because~it~arrives~after~the~last~row~of~the~environment. \\
    If~you~go~on,~this~arrow~will~be~ignored.
  }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nn { WithArrows~outside~math~mode }
  { 
    The~environment~\{\l_@@_type_env_str\}~should~be~used~only~in~math~mode~
    like~the~environment~\{aligned\}~of~amsmath. \\
    Nevertheless,~you~can~go~on.
  }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nn { DispWithArrows~in~math~mode }
  { 
    The~environment~\{\l_@@_type_env_str\}~should~be~used~only~outside~math~
    mode~like~the~environment~\{align\}~of~amsmath. \\ 
    This~error~is~fatal.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Incompatible~options~in~Arrow }
  { 
    You~try~to~use~the~option~'\l_keys_key_tl'~but~
    this~option~is~incompatible~or~redundant~with~the~option~
    '\l_@@_previous_key_str'~set~in~the~same~command~
    \l_@@_string_Arrow_for_msg_str. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
% 
%
%    \begin{macrocode}          
\@@_msg_new:nn { Incompatible~options }
  { You~try~to~use~the~option~'\l_keys_key_tl'~but~
    this~option~is~incompatible~or~redundant~with~the~option~
    '\l_@@_previous_key_str'~set~in~the~same~command~
    \bool_if:NT \l_@@_in_code_after_bool
      { 
        \l_@@_string_Arrow_for_msg_str\
        in~the~code-after~of~your~environment~\{\l_@@_type_env_str\}
      }. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Arrow~not~in~last~column }
  { 
    You~should~use~the~command~\l_@@_string_Arrow_for_msg_str\
    only~in~the~last~column~(column~\int_use:N\l_@@_nb_cols_int)~
    of~your~environment~\{\l_@@_type_env_str\}.\\
    However~you~can~go~on~for~this~time.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Wrong~line~in~Arrow }
  { 
    The~specification~of~line~'#1'~you~use~in~the~command~
    \l_@@_string_Arrow_for_msg_str\
    in~the~'code-after'~of~\{\l_@@_type_env_str\}~doesn't~exist. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Both~lines~are~equal }
  {
    In~the~'code-after'~of~\{\l_@@_type_env_str\}~you~try~to~
    draw~an~arrow~going~to~itself~from~the~line~'#1'.~This~is~not~possible. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
% 
%    \begin{macrocode}
\@@_msg_new:nn { Wrong~line~specification~in~MultiArrow }
  { 
    The~specification~of~line~'#1'~doesn't~exist. \\
    If~you~go~on,~it~will~be~ignored~for~\token_to_str:N \MultiArrow.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Too~small~specification~for~MultiArrow }
  { 
    The~specification~of~lines~you~gave~to~\token_to_str:N \MultiArrow\ 
    is~too~small:~you~need~at~least~two~lines. \\
    \c_@@_command_ignored_str
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\@@_msg_new:nn { Not~allowed~in~DispWithArrows }
  { 
    The~command~\token_to_str:N #1
    is~allowed~only~in~the~last~column~
    (column~\int_use:N\l_@@_nb_cols_int)~of~\{\l_@@_type_env_str\}. \\ 
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
% 
%    \begin{macrocode}
\@@_msg_new:nn { Not~allowed~in~WithArrows }
  { 
    The~command~\token_to_str:N #1 is~not~allowed~in~\{\l_@@_type_env_str\}~
    (it's~allowed~in~the~last~column~of~\{DispWithArrows\}). \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<*LaTeX>
\@@_msg_new:nn { tag*~without~amsmath }
  { 
    We~can't~use~\token_to_str:N\tag*~because~you~haven't~loaded~amsmath~
    (or~mathtools). \\
    If~you~go~on,~the~command~\token_to_str:N\tag\ 
    will~be~used~instead.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Multiple~tags }
  {
    You~can't~use~twice~the~command~\token_to_str:N\tag\ 
    in~a~line~of~the~environment~\{\l_@@_type_env_str\}. \\
    If~you~go~on,~the~tag~'#1'~will~be~used.
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\@@_msg_new:nn { Multiple~labels }
  { 
    Normally,~we~can't~use~the~command~\token_to_str:N\label\ 
    twice~in~a~line~of~the~environment~\{\l_@@_type_env_str\}. \\
    However,~you~can~go~on.~
    \bool_if:NT \c_@@_showlabels_loaded_bool
      { However,~only~the~last~label~will~be~shown~by~showlabels.~ }
    If~you~don't~want~to~see~this~message~again,~you~can~use~the~option~
    'allow-multiple-labels'~at~the~global~or~environment~level.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Multiple~labels~with~cleveref }
  {
    Since~you~use~cleveref,~you~can't~use~the~command~\token_to_str:N\label\ 
    twice~in~a~line~of~the~environment~\{\l_@@_type_env_str\}. \\
    If~you~go~on,~you~may~have~undefined~references.
  }
%</LaTeX>
%    \end{macrocode}
%
% 
%    \begin{macrocode}
\@@_msg_new:nn { Inexistent~v-node }
  {
    There~is~a~problem.~Maybe~you~have~put~a~command~\token_to_str:N\cr\
    instead~of~a~command~\token_to_str:N\\~at~the~end~of~
    the~row~\l_tmpa_int\
    of~your~environment~\{\l_@@_type_env_str\}. \\
    This~error~is~fatal.
  }
%    \end{macrocode}
%
% \bigskip
% The following error when the user tries to use the option |xoffset| in mode
% |group| or |groups| (in fact, it's possible to use the option |xoffset| if
% there is only \emph{one} arrow: of course, the option |group| and |groups| do
% not make sense in this case but, maybe, the option was set in a
% |\WithArrowsOptions|). 
%    \begin{macrocode}          
\@@_msg_new:nn { Option~xoffset~forbidden }
  { 
    You~can't~use~the~option~'xoffset'~in~the~command~
    \l_@@_string_Arrow_for_msg_str\ in~the~row~\int_use:N \g_@@_line_int\ 
    of~your~environment~\{\l_@@_type_env_str\}~
    because~you~are~using~the~option~
    ' \int_compare:nNnTF \l_@@_pos_arrow_int = 7
        { group } 
        { groups } '.~It's~possible~for~an~independent~arrow~or~if~there~is~
    only~one~arrow. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nnn { Duplicate~name }
  { 
    The~name~'\l_keys_value_tl'~is~already~used~and~you~shouldn't~use~
    the~same~environment~name~twice.~You~can~go~on,~but,~
    maybe,~you~will~have~incorrect~results. \\
    For~a~list~of~the~names~already~used,~type~H~<return>. \\ 
    If~you~don't~want~to~see~this~message~again,~use~the~option~
    'allow-duplicate-names'. 
  }
  {
    The~names~already~defined~in~this~document~are:~
    \seq_use:Nnnn \g_@@_names_seq { ,~ } { ,~ } { ~and~ }.
  }
%    \end{macrocode}
%
% 
%
% \subsection{The command \textbackslash WithArrowsNewStyle}
%
% A new key defined with |\WithArrowsNewStyle| will not be available at the
% local level.
%    \begin{macrocode}
%<*LaTeX>
\NewDocumentCommand \WithArrowsNewStyle { m m }
%</LaTeX>
%<*plain-TeX>
\cs_new_protected:Npn \WithArrowsNewStyle #1 #2 
%</plain-TeX>
  { 
    \keys_if_exist:nnTF { WithArrows / Global } { #1 }
      { \@@_error:nn { Key~already~defined } { #1 } }
      { 
        \keys_define:nn { WithArrows / Global }
          { 
            #1 .code:n = 
             { \keys_set_known:nn { WithArrows / WithArrowsOptions } { #2 } }
          } 
        \seq_put_right:Nx \l_@@_options_WithArrows_seq { \tl_to_str:n { #1 } }
        \seq_put_right:Nx \l_@@_options_DispWithArrows_seq 
          { \tl_to_str:n { #1 } }
        \seq_put_right:Nx \l_@@_options_WithArrowsOptions_seq 
          { \tl_to_str:N { #1 } }
%    \end{macrocode}
% We now set the options in a TeX group in order to detect if some keys in |#2|
% are unknown. If a key is unknown, an error will be raised. However, the key
% will, even so, be stored in the definition of key~|#1|. 
%    \begin{macrocode}
        \group_begin:
          \msg_set:nnn { witharrows } { Unknown~option~WithArrowsOptions }
            {
              The~key~'\l_keys_key_tl'~can't~be~set~in~the~
              definition~of~a~style.~You~can~go~on~for~this~time~
              but~you~should~suppress~this~key. 
            }
          \WithArrowsOptions { #2 }
        \group_end:
      } 
  }
%    \end{macrocode}
% 
%    \begin{macrocode}
\@@_msg_new:nn { Key~already~defined }
  {
    The~key~'#1'~is~already~defined. \\
    If~you~go~on,~your~instruction~\token_to_str:N\WithArrowsNewStyle\ 
    will~be~ignored.
  }
%    \end{macrocode}
%
%
% \subsection{The options up and down}
%
% The options |up| and |down| are available for individual arrows. The
% corresponding code is given here. It is independent of the main code of the
% extension \pkg{witharrows}.
% 
% This code is the only part of the code of \pkg{witharrows} which uses the
% package \pkg{varwidth} and also the Tikz library |calc|. That's why we have
% decided not to load this package and this library. If they are not loaded, the
% user will have an error only when using the option |up| or the option |down|.
% 
% \medskip
% The token list |\c_@@_tikz_code_up_tl| is the value of |tikz-code| which will
% be used for an option |up|.
%    \begin{macrocode}
\tl_const:Nn \c_@@_tikz_code_up_tl
  {
    \draw [ rounded~corners ]
       let \p1 = (#1) ,
           \p2 = (#2)
       in (\p1) -- node { 
%<*LaTeX>
                          \dim_set:Nn \l_tmpa_dim { \x2 - \x1 }
                          \begin { varwidth } \l_tmpa_dim
%    \end{macrocode}
% |\narrowragged| is a command of the package \pkg{varwidth}.
%    \begin{macrocode}
                            \narrowragged
                            #3
                          \end { varwidth } 
%</LaTeX>
%<*plain-TeX>
                            #3
%</plain-TeX>
                        } 
          (\x2,\y1) -- (\p2) ;
  }
%    \end{macrocode}
% 
%
% \medskip
% Idem for the option |down|.
%    \begin{macrocode}
\tl_const:Nn \c_@@_tikz_code_down_tl
  {
    \draw [ rounded~corners ]
      let \p1 = (#1) ,
          \p2 = (#2)
      in (\p1) -- (\x1,\y2) --
               node {
%<*LaTeX>
                      \dim_set:Nn \l_tmpa_dim { \x1 - \x2 }
                      \begin { varwidth } \l_tmpa_dim
                        \narrowragged
                        #3
                      \end { varwidth }
%</LaTeX>
%<*plain-TeX>           
                        #3
%</plain-TeX>
                    } 
               (\p2) ;
  }
%    \end{macrocode}
% 
%    \begin{macrocode}
\keys_define:nn { WithArrows / Arrow / FirstPass }
  {
    up   .code:n = \@@_set_independent: ,
    down .code:n = \@@_set_independent: ,
    up   .default:n = NoValue ,
    down .default:n = NoValue 
  }
%    \end{macrocode}
% 
% \bigskip
%    \begin{macrocode}
\keys_define:nn { WithArrows / Arrow / SecondPass }
  { 
    up .code:n =  
      \str_if_empty:NT \l_@@_previous_key_str
        { 
          \str_set:Nn \l_@@_previous_key_str { up }
%<*LaTeX>
          \bool_if:NTF \c_@@_varwidth_loaded_bool
            { 
%</LaTeX>
              \cs_if_exist:cTF { tikz@library@calc@loaded }
                { 
                  \int_set:Nn \l_@@_pos_arrow_int \c_one_int
%    \end{macrocode}
% We have to set |\l_@@_wrap_lines_bool| to |false| because, otherwise, if the
% option |wrap_lines| is used at a higher level (global or environment), we will
% have a special affectation to |tikz-code| that will overwrite our affectation.
%    \begin{macrocode}
                  \bool_set_false:N \l_@@_wrap_lines_bool
                  \tl_set_eq:NN \l_@@_tikz_code_tl 
                    \c_@@_tikz_code_up_tl
                }
                { \@@_error:n { calc~not~loaded } }
%<*LaTeX>
            }
            { \@@_error:n { varwidth~not~loaded } } 
%</LaTeX>
        } ,
    down .code:n = 
      \str_if_empty:NT \l_@@_previous_key_str
        { 
          \str_set:Nn \l_@@_previous_key_str { down }
%<*LaTeX>
          \bool_if:NTF \c_@@_varwidth_loaded_bool
            { 
%</LaTeX>
              \cs_if_exist:cTF { tikz@library@calc@loaded }
                { 
                  \int_set:Nn \l_@@_pos_arrow_int \c_one_int
                  \bool_set_false:N \l_@@_wrap_lines_bool
                  \tl_set_eq:NN \l_@@_tikz_code_tl 
                    \c_@@_tikz_code_down_tl
                }
                { \@@_error:n { calc~not~loaded } }
%<*LaTeX>
            }
            { \@@_error:n { varwidth~not~loaded } } 
%</LaTeX>
        }
  }
%    \end{macrocode}
%
%    
% 
%    \begin{macrocode}
\seq_put_right:Nn \l_@@_options_Arrow_seq { down }
\seq_put_right:Nn \l_@@_options_Arrow_seq { up }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\@@_msg_new:nn { varwidth~not~loaded } 
  {
    You~can't~use~the~option~'\l_keys_key_tl'~because~
    you~don't~have~loaded~the~package~'varwidth'. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
% 
%    \begin{macrocode}
\@@_msg_new:nn { calc~not~loaded }
  { 
    You~can't~use~the~option~'\l_keys_key_tl'~because~you~don't~have~loaded~the~
    Tikz~library~'calc'.You~should~add~'\token_to_str:N\usetikzlibrary{calc}'~
    ~in~the~preamble~of~your~document. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Invalid~specification~for~MultiArrow }
  {
    The~specification~of~rows~for~\token_to_str:N\MultiArrow\ 
    (i.e.~#1)~is~invalid. \\  
    \c_@@_command_ignored_str
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
%<*plain-TeX>
\catcode `\@ = 12
\ExplSyntaxOff
%</plain-TeX>
%    \end{macrocode}
% 
% \section{History}
%
% \subsection*{Changes between versions 1.0 and 1.1}
% 
% Option for the command |\\| and option |interline|
% 
% Compatibility with |\usetikzlibrary{babel}|
%
% Possibility of nested environments |{WithArrows}|
% 
%
% \subsection*{Changes between versions 1.1 and 1.2}
%
% The package \pkg{witharrows} can now be loaded without having loaded
% previously \pkg{tikz} and the libraries |arrow.meta| and |bending| (this
% extension and these libraries are loaded silently by \pkg{witharrows}).
%
% New option |groups| (with a \emph{s})
%
% 
% \subsection*{Changes between versions 1.2 and 1.3}
% 
% New options |ygap| and |ystart| for fine tuning.
%
% \subsection*{Changes between versions 1.3 and 1.4}
% 
% The package \pkg{footnote} is no longer loaded by default. Instead, two
% options |footnote| and |footnotehyper| have been added. In particular,
% \pkg{witharrows} becomes compatible with \cls{beamer}.
% 
% \subsection*{Changes between versions 1.4 and 1.5}
% 
% The Tikz code used to draw the arrows can be changed with the option
% |tikz-code|.
%
% Two new options |code-before| and |code-after| have been added at the
% environment level.
%
% A special version of |\Arrow| is available in |code-after| in order to draw
% arrows in nested environments.
% 
% A command |\MultiArrow| is available in |code-after| to draw arrows of other
% shapes.
% 
% \subsection*{Changes between versions 1.5 and 1.6}
% 
% The code has been improved to be faster and the Tikz library |calc| is no
% longer required.
%
% A new option |name| is available for the environments |{WithArrows}|.
%
% \subsection*{Changes between 1.6 and 1.7}
%
% New environments |{DispWithArrows}| and |{DispWithArrows*}|.
%
% \subsection*{Changes between 1.7 and 1.8}
%
% The numbers and tags of the environment |{DispWithArrows}| are now compatible
% with all the major LaTeX packages concerning references (\pkg{autonum},
% \pkg{cleveref}, \pkg{fancyref}, \pkg{hyperref}, \pkg{prettyref},
% \pkg{refstyle}, \pkg{typedref} and \pkg{varioref}) and with the options
% |showonlyrefs| and |showmanualtags| of \pkg{mathtools}.
%
% \subsection*{Changes between 1.8 and 1.9}
% 
% New option |wrap-lines| for the environments |{DispWithArrows}| and
% |{DispWithArrows*}|.
%
% \subsection*{Changes between 1.9 and 1.10}
%
% If the option |wrap-lines| is used, the option ``|text width|'' of Tikz is
% still active: if the value given to ``|text width|'' is lower than the width
% computed by |wrap-lines|, this value is used to wrap the lines.
%
% The option |wrap-lines| is now fully compatible with the class option |leqno|.
%
% Correction of a bug: |\nointerlineskip| and |\makebox[.6\linewidth]{}| should
% be inserted in |{DispWithArrows}| only in vertical mode.
%
% \subsection*{Changes between 1.10 and 1.11}
%
% New commands |\WithArrowsNewStyle| and |\WithArrowsRightX|.
%
% \subsection*{Changes between 1.11 and 1.12}
%
% New command |\tagnextline|.
%
% New option |tagged-lines|.
%
% An option of position (|ll|, |lr|, |rl|, |rr| or |i|) is now allowed at the
% local level even if the option |group| or the option |groups| is used at the
% global or environment level.
%
% Compatibility of |{DispWithArrows}| with |\qedhere| of \pkg{amsthm}.
%
% Compatibility with the packages \pkg{refcheck}, \pkg{showlabels} and
% \pkg{listlbls}.
%
% The option |\AllowLineWithoutAmpersand| is deprecated because lines without
% ampersands are now always allowed.
%
% \subsection*{Changes between 1.12 and 1.13}
%
% Options |start-adjust|, |end-adjust| and |adjust|.
% 
% This version is not stricty compatible with previous ones. To restore the
% behaviour of the previous versions, one has to use the option |adjust| with
% the value $0$~pt:
% 
% \begin{Verbatim}
% \WithArrowsOptions{adjust = 0pt}
% \end{Verbatim}
%
% \subsection*{Changes between 1.13 and 1.14}
%
% New options |up| and |down| for the arrows.
%
% \smallskip
% Replacement of some options |O { }| in commands and environments defined with
% \pkg{xparse} by |! O { }| (a recent version of \pkg{xparse} introduced
% the specifier |!| and modified the default behaviour of the last optional
% arguments:
% |//www.texdev.net/2018/04/21/xparse-optional-arguments-at-the-end|).
%
% \smallskip
% Modification of the code of |\WithArrowsNewStyle| following a correction of a
% bug in \pkg{l3keys} in the version of \pkg{l3kernel} of 2019/01/28.
% 
% New error message |Inexistent~v-node| to avoid a \pkg{pgf} error.
%
% The error |Option incompatible with 'group(s)'| was suppressed in the version
% 1.12 but this was a mistake since this error is used with the option |xoffset|
% at the local level. The error is put back.
% 
% \subsection*{Changes between 1.14 and 1.15}
%
% Option |new-group| to start a new group of arrows (only available when the
% environment is composed with the option |groups|).
%
% Tikz externalization is now deactivated in the environments of the
% extension \pkg{witharrows}.\footnote{Before this version, there was an error
% when using \pkg{witharrows} with Tikz externalization. In any case, it's not
% possible to externalize the Tikz elements constructed by \pkg{witharrows}
% because they use the options |overlay| and |remember picture|.} 
%
% \subsection*{Changes between 1.15 and 1.16}
%
% Option |no-arrows| 
%
% The behaviour of |{DispWithArrows}| after an |\item| of a LaTeX list has been
% changed : no vertical is added. The previous behaviour can be restored with
% the option |standard-behaviour-with-items|.
% 
% A given name can no longer be used for two distinct environments. However,
% it's possible to deactivate this control with the option
% |allow-duplicate-names|.
% 
%
% \subsection*{Changes between 1.16 and 1.17}
% 
% Option |format|.
%
% \subsection*{Changes between 1.17 and 1.18}
%
% New option |<...>| for |{DispWithArrows}|.
%
% Option |subequations|.
%
% Warning when |{WithArrows}| or |{DispWithArrows}| ends by "\\".
% 
% No space before an environment |{DispWithArrows}| if we are at the beginning
% of a |{minipage}|.
%
% \subsection*{Changes between 1.18 and 2.0}
% 
% A version of \pkg{witharrows} is available for plain-TeX.
% 
%
% \subsection*{Changes between 2.0 and 2.1}
% 
% Option |max-length-of-arrow|.
% 
% Validation with regular expression for the first argument of |\MultiArrow|.
%
% \subsection*{Changes between 2.1 and 2.2}
%
% Addition of |\normalbaselines| at the beginning of |\@@_post_halign:|.
%
% The warning for an environment ending by |\\| has been transformed in |error|.
%
% \PrintIndex
%
% \tableofcontents
%
% \endinput
% Local Variables:
% TeX-fold-mode: t
% TeX-fold-preserve-comments: nil
% fill-column: 80
% ispell-local-dictionary: english
% End:
